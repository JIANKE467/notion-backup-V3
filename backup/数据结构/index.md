---
{
  "id": "2625a2dd-8276-80ed-a068-ebc863928325",
  "url": "https://www.notion.so/2625a2dd827680eda068ebc863928325",
  "created_time": "2025-09-02T06:47:00.000Z",
  "last_edited_time": "2025-11-29T09:32:00.000Z"
}
---

# 🥵 数据结构

数据结构就是
对数据的增，删，改，查
我们讨论的数据结构的问题一般都是指在没有硬件虚拟化的机器上（如连续内存空间和不连续内存空间）
[1.1时间复杂度](11时间复杂度/index.md)
  ### 时间复杂度
  由于不同机器性能不同，无法相互比较，因此，时间复杂度是以程序循环的次数为度量的
  PS：时间复杂度度量的是逻辑次数，而非指令次数，所以只计量循环次数

  时间复杂度是一个式子
  $$
F（N）=.....
$$
  F(N)是时间复杂度
  N是执行次数
  如：
  $$
F（N）=N^2+2N+10
$$

  ### 时间复杂度估算（时间复杂度渐进表示）（大O表示法）
  将对式子影响最大的一项留下，剩下部分去掉，就是时间复杂度的渐进表示：
  用O（N）表示
  基于上个例子：时间复杂度渐进表示为
  $$
O（N^2）
$$

  PS：时间复杂度渐进表示有大O表示法，大Ω表示法，大Θ表示法，这里只讨论大O表示法↓

  规则：
  1. 只保留最高阶
  例：
  $$
T(n)=n^2+5n+7 \quad \Rightarrow \quad O(n^2)
$$
  1. 忽略系数  [常数是变量不能忽略，如  T(N) =kN ]
  例：
  $$
T(n)=10n^3 \quad \Rightarrow \quad O(n^3)
$$
  1. 如果只有常数（如循环100次），直接常数改成1
  例：
  $$
F（100）→O（1）
$$



  PS：如果有m次的和n次的两个循环，顺序执行则↓
  不知道m，n大小关系：则全部保留         
  $$
O（m+n）
$$
  m＞n：则只保留m
  $$
O（m）
$$
  m＜n：则只保留n
  $$
O（n）
$$

  PS：时间复杂度有：最好，平均，最坏
  一般取最坏的时间复杂度作为程序时间复杂度

  ### 冒泡排序的时间复杂度
  冒泡排序：从头开始两两相比，如果前比后大则交换
  最坏情况：倒序排成正序
  循环次数：（n-1）+（n-2）+……+1
  时间复杂度：（等差数列求和公式）
  $$
F(n)=\frac{n*(n-1)}{2}
$$
  渐进表示：（n乘进去分数拆开）
  $$
O=n^2
$$
  注意⚠️：时间复杂度不能只看循环次数，要看算法逻辑（循环次数不一定是固定的）
[二章：线性表](二章线性表/index.md)
  1.1顺序表
    顺序表在逻辑内存上是连续的（未虚拟化的内存），但在物理上不一定是连续的
    顺序表就是数组，它要求数据连续
    ## 顺序表的实现——静态分配
      使用静态数组（固定大小的数组）叫静态分配
      ### 定义顺序表本体部分
      ```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100 // 定义顺序表大小
typedef struct {
   int data[MAX_SIZE]; // 用数组存数据
   int length; // 顺序表当前长度
} SeqList;
      ```
      **代码解释：**
      Q：第四行typedef struct是什么意思？其后的SeqList还是结构体变量吗？
      **A：typedef struct与最后的SeqList意思是将这个未命名的结构体重命名成SeqList。**
      **与正常结构体不同，此时的结构体后跟的并非成员列表，而是别名，所以此时的SeqList不是结构体变量。**
      **推荐使用的标识符：**
      MAX_SIZE：顺序表（数组）最大容量，单位不是字节，与顺序表定义的数据类型有关，如int就是4字节一组
      lenth：顺序表当前容量
      推荐将数组和已用容量打包成结构体（便于维护），再将结构体名重命名为SeqList
      Sq是顺序的缩写，List是表
      **Q &A：**
      Q: 顺序表就是数组，为什么还要先构建结构体，再在结构体成员中定义数组？
      A. 可以直接用数组（存储数据）+一个变量（记录存了多少数据）。但在做顺序表调用的实现时需要修改两个元素，带来两个问题：
      1. 代码量一大，人就看不懂，一个数组+一个变量，是干嘛的
      1. 其他实现方式也可以，但这是标准做法
      PS：到了这里是顺序表仅仅是定义了还未声明，需要在主函数中声明，也就是只定义了结构体名，没有定义结构体变量列表，需要在主函数中定义结构体变量名。
      ### 初始化顺序表（函数）
      - 需要将length变量（顺序表长度）赋为0
      - 需要将数组中的每个元素赋值为0（内存中有脏数据）（用一个for循环实现）
      ```c
void InitList (SeqList){
  for (int i=0; i<MaxSize; i++)
    L.data=0;
  L.length=0;
}
      ```
      ### 主函数
      ```c
int main(){
  SeqList L; //声明一个顺序表
  InitList(L); //初始化顺序表
  //...后续操作
  return 0;
}
      ```
    ## 顺序表的实现——动态分配
      ### 定义顺序表本体部分
      定义一个指针（用于指向表的首元素）
      定义一个变量length（用于指示表的当前长度）
      定义一个变量MaxSize（用于指示表的最大容量）
      ```c
#include<stdlib.h> //malloc函数的头文件
#define InitSize 10
typedef struct{
  ElemType *data;
  int MaxSize;
  int length;
} SeqList;
      ```
      ### 初始化表（函数）
      用malloc动态申请空间（malloc返回的指针要强制转换为与要存储数据一致的类型）
      给最大容量赋值为InitSize（InitSize在前面定义为常量）
      给当前长度赋0
      **PS：malloc函数=数组（所以动态分配中没见到数组）**
      ```c
voud InitList(SeqList &L){
  //用malloc申请一片空间
  L.data=(int*)malloc (InitSize*sizeof (int));
  L.length=0;
  L.MaxSize=InitSize;
}
      ```
      ### 在实现一个表扩容(函数)
      传参：顺序表，增加的长度len
      定义一个指针，将 L.data赋给该指针（表起始位置指针）
      用malloc重新申请一片比原来大的空间,赋值给L.data
      用for循环将原表p中的数据移过去L.data
      修改变量MaxSize（最大容量）
      调用free函数将原空间释放
      ```c
void IncreaseSize(SeqList &L,int len){
  int *p=L.data;
  L.data=(int *)malloc ((L.MaxSize+len)*size of (int));
  for (int i=0;i<L.length;i++){
    L.data[i]=p[i]; //用数组的方式调用
  }
  L.MaxSize=L.MaxSize+len;
  free (p);
}
      ```
      PS：也可以使用realloc代替这个函数的功能，但推荐使用上面介绍的实现方法
      PS：为什么L.data [i] = p [i] 用数组的调用方法？同样的问题，为什么动态分配结构体内没有数组？
      因为在初始化函数中，**malloc相当于申请了一个数组（事实上是连续内存空间，这块空间可以当数组使用）**，所以这里使用数组的调用，结构体中也不用数组。
    # 顺序表的特点
    **随机访问**：因为是按顺序存储，可以在O（1）[循环次数为确定常数] 时间复杂度找到任意元素
    **存储密度高**：每个节点只存储数据，不存储指针
    **扩容不方便：**扩容需要复制一遍，时间复杂度高
    **插入删除不便：**插入删除需要移动大量数据
  1.2顺序表的插入/删除
    PS：本节以静态分配为例
    ### 顺序表插入函数
      传入参数：i（插入位置），顺序表，e（插入元素）
      **验证逻辑↓**
      用if验证i（插入位置）合法性（0～lenth+1），不合法则return一个值（表示i不合法）
      用if验证lenth>=MaxSize，成立则返回一个值（表示空间不足）
      **主逻辑↓**
      用一个for循环让表的元素从lenth（当前长度）处依次后移一位，直到i（插入位置）停止
      插入元素e
      lenth（当前长度）加1
      return一个值（表示插入成功）
      ```c
bool ListInsert(SqList &L,int i,int e){
  //插入位置合法判断
  if(i<1||i>L.length+1)
    return false;
  //顺序表是否已满判断
  if(L.length>=MaxSize)
    return false;
  //将第i个元素及之后的元素后移
  for (int j=L.length;j>=i;j--)
    L.data[j]=L.data[j-1];
  //在i处插入元素e
  L.data[i-1]=e;
  //长度加1
  L.length++;
  return true;
}
      ```
    ### 顺序表删除函数
      传入参数：i（删除位置），顺序表，e（返回删除的元素）
      **验证逻辑↓**
用if验证i（插入位置）合法性（0～lenth+1），不合法则return一个值（表示i不合法）
      **主逻辑↓**
      将要删除的元素赋给e
      用for循环实现i后的元素依次前移
      lenth减1
      返回值（表示成功）
      ```c
bool ListDelete(SqList &L,int i,int &e){
  //判断i的范围是否有效
  if(i<1l |i>L.length) 
    return false;
  //将被删除的元素赋值给e
  e=L.data[i-1]; 
  //将第i个位置后的元素前移L
  for(int j=i;j<L.length;j++)
    L.data[j-1]=L.data[j]; 
  //线性表长度减1
  L.length--; 
  return true;
}
      ```
      注意⚠️：
      函数的参数只能传入，对于传入的参数的修改不能直接生效，需要通过return来返回（因为传入的参数实际上是原参数的副本），或通过传入引用符号+原参数 来实现修改后立即生效
  1.3顺序表查找
    # 按位查找
      ### 静态分配
        查找第i位的值
        （以静态数组顺序表为例）
        直接调用结构体，成员，数组下标即可（可以加逻辑判断i位是否合法）

        ```c
ElemType GetElem(Sqlist L,int i)
{
return L.data[i-1];
}
        ```
      ### 动态分配
        同样可以用结构体，成员，数组下标的方式访问
        动态分配中malloc≈数组，它通过其前面的数据类型规定了数组一个元素空间大小，通过后面的值规定了数组长度
        **因此malloc与数组访问方式相同（通过下标访问）（要将数组名替换为malloc首元素指针）**
        ```c
ElemType GetElem(SeqList L, int i){
  return L.data[i-1];
}
        ```
      ### 时间复杂度
      O（1）
    # 按值查找
      查找有关键字的元素
      用一个自增的for循环嵌套一个if判断，当：关键字==数组元素 时，return这个值的下标
      ```c
int Loc ateElem(SeqList L,int e){
  for(int i=0;icL. Length；i++)
    if(L.data[i]==e)
      return i+1;
  return 0;
} 
      ```
      PS：
      这个代码有一个问题：
      如果数组中有多个相同的值，只能查找出第一个值
      ### 时间复杂度
      最好：循环1次：O（1）
      最坏：循环n次：O（n）
      平均：O（n）

      注意⚠️：位序=下标+1
  线性表用公式表示为
  n为表长

  $$
L=（a_1，a_2....a_n）
$$
  ### 线性表的基本操作
  1. 初始化表 lnitList(&L)：构造空线性表，分配内存空间。
  1. 销毁操作 DestroyList(&L)：释放线性表L的内存空间
  1. Listlnsert（&L，i，e）：插入操作，在表L的i位置插入e
  1. ListDelete（&L，i，&e）：删除操作，删除表L的i位置的值并用e返回删除元素的值
  1. LocateElem（L，e）：按值查找，在表L中找e
  1. GetElem（L，i）：按位查找，在表L中找i位置的值
  **其他常用操作**
  1. Length（L）：求表长，返回线性表长度
  1. PrintList（L）：输出操作，输出线性表L中的所有值
  1. Empty（L）：空操作，若L为空表返回true，否则返回false

  2.1单链表定义
    与顺序表区别：顺序表每个结点只存数据，链表每个节点不仅有数据还有下一个节点的地址
    单链表指单向链接，只能从头到尾访问
    单链表不支持随机访问
    ![](assets/27b5a2dd-8276-8056-9671-cb1068d7e754.jpg)
    ### 定义
    定义一个结构体LNode，有两个成员：
    1. 某类型的变量（数据域，用来存放数据）
    1. 下一节点的指针（指针域）（声明一个为该结构体所表示的数据类型的指针，指针名为next）

    ```c
struct LNode{
  ElemType data;
  struct LNode *next;
  };
    ```
    ### 重命名struct LNode
    用typedef
    ```c
typedef struct LNode LNode* 
typedef struct LNode LinkList
    ```
    这两个等价，只是为了提高可读性
    强调这是一个单链表用LinkList
    强调这是一个节点用LNode*（这个*只是为了说明该节点是一个指针，不加不影响什么）
    ### 初始化单链表函数（不带头节点）
    初始化空单链表：给头节点赋值为空
    ```c
bool InitList(LinkList &L){
  L = NULL;
  return true;
  }
    ```
    PS：
    1. 将头节点设为NULL是为了防止内存中有脏数据
    1. **使用LinkList & L（引用L），而非LinkList L（直接传入L），是因为直接传入L修改的是L的副本**
    **还可以加一个判断逻辑，判断头节点是否为空：（空表判断）**
    ```c
bool Empty(LinkList L){
  if (L==NULL)
    return true;
  else
    return false;
}
    ```
    ### 初始化单链表函数（带头节点）(多数）
    用malloc分配一个头节点给L（结构体声明返回的是一个指针，L就是该指针）
    判断是否分配成功L是否为NULL
    将第一个节点的指针域设为NULL
    ```c
bool InitList(LinkList &L){
  L=(LNode*) malloc (sizeof(LNode));
  if (L==NULL)
    return false;
  L->next =NULL;
  return true;
}
    ```
    **还可以增加一个判断逻辑，看指针域是否为空：（空表判断）**
    ```c
bool Empty(LinkList L){
  if (L->next==NULL)
    return true;
  else
    return false;
}

    ```
    ### 总结：
    带头结点空表判断：头节点指针域为空
    不带头节点空表判断：头节点的指针为空
  2.2单链表插入删除
    # 按位序插入
    在第i个位置插入指定元素e
    ### 带头节点（头节点不存数据）（函数如下）
    1.找出要插入的位置的上一个节点的地址
    方法：定义一个结构体变量*p用来表示第i-1个节点的地址
    先将结构体变量*p初始化到头节点（第0个节点）上，然后通过循环不断将*p修改到下一个节点的指针上，直到到达第i-1个节点（该循环需要一个节点号计数器j，用来指示循环到了第几个节点）
    ```c

    ```
    2.使用malloc申请一个新节点*s
    ```c

    ```
    3.将新节点s的数据域赋值为e（插入内容），将新节点s指针域赋值为p（上一节点）的指针域，将p节点（上一结点）的指针域修改为新节点的指针（不是指针域）
    ```c

    ```
    ### 不带头节点（函数如下）
    除了插入第一个节点操作不同，其他与带头节点的函数相同：
    因此用分支判断插入第几个节点
    第一个节点：
    malloc申请新节点*s
    新节点s的数据域赋值为e（插入内容），新节点s指针域赋值为p（上一节点）的指针域，将p节点（上一结点）的指针域修改为新节点的指针（不是指针域）
    ```c

    ```
    另一分支注意将*p初始化为第一个节点（不是头节点）
    # 前插入

    # 删除
[重构](重构/index.md)
  重构分两个部分
  1.定义（实现原理）：各种大类要包括分出来的小类。如：线性表要知道下属类别：顺序表和其下属类别：顺序表插入/静态分配
  > 注重实现方法，代码用文字描述
  > 每个最小页面内用函数分类，一个函数写一块，写出总结：将什么几个功能写成几个个函数？**画一个层级图**
  2.实现（实现代码）
  > 注重代码，用链接链接到1，写出代码，同样一个函数写一块
  ```plain text
数据结构
│
├── 一、绪论
│     ├── 数据结构三要素
│     │     ├ 数据的逻辑结构
│     │     ├ 数据的存储结构
│     │     └ 数据的运算
│     ├── 四种逻辑结构
│     │     ├ 集合
│     │     ├ 线性结构
│     │     ├ 树形结构
│     │     └ 图结构
│     └── 常用时间复杂度
│           ├O(1)  
│           ├O(n)
│           ├O(n log n)
│           └O(n²)
│
├── 二、线性表  ★重点
│     ├ 顺序表
│     ├ 链表
│     │     ├ 单链表
│     │     ├ 双链表
│     │     └ 循环链表
│     ├ 基本操作
│     │     ├ 插入（移动/指针）
│     │     ├ 删除
│     │     └ 查找
│     └ 与链表比较（时间/空间/效率）
│
├── 三、栈与队列 ★高频
│     ├ 栈（后进先出）
│     │     ├ 入栈/出栈
│     │     └ 表达式求值
│     ├ 队列（先进先出）
│     └ 循环队列（判空判满）
│
├── 四、串（了解）
│     ├ BF匹配
│     ├ KMP
│     │     └ next数组
│     └ 模式匹配复杂度
│
├── 五、树与二叉树 ★大题区
│     ├ 二叉树概念
│     │     ├ 满
│     │     ├ 完全
│     │     └ 性质
│     ├ 遍历
│     │     ├ 先
│     │     ├ 中
│     │     ├ 后
│     │     └ 层次
│     ├ 二叉排序树
│     └ 平衡树AVL
│
├── 六、图  ★难点
│     ├ 邻接矩阵
│     ├ 邻接表
│     ├ DFS
│     ├ BFS
│     ├ 最小生成树
│     │     ├ Prim
│     │     └ Kruskal
│     └ 最短路径
│           ├ Dijkstra
│           └ Floyd
│
├── 七、查找
│     ├ 顺序查找
│     ├ 折半查找
│     ├ 二叉排序树
│     ├ AVL树
│     ├ 哈希表
│     │     └ 冲突处理：链地址/开放地址
│
└── 八、排序 ★考得最多
      ├ 内部排序
      │   ├ 冒泡
      │   ├ 选择
      │   ├ 插入
      │   ├ 快排
      │   ├ 归并
      │   └ 堆排
      ├ 时间复杂度
      └ 稳定性
  ```
  线性表
    顺序表
      # 描述
        顺序表是一种线性数据结构,它使用一组连续的内存空间来存储数据元素。在顺序表中,元素按照逻辑顺序依次存放,每个元素的位置由其下标(索引)确定。这种存储方式使得顺序表可以实现快速的随机访问,时间复杂度为O(1)。
        **顺序表 = 用一段连续的内存顺序存放数据的线性表。**

        ![](assets/2c95a2dd-8276-81c1-a04f-d23ab5be131e.jpg)
        （以上图为内存结构）
      # 内存特点
      连续的内存
      # 节点结构
      只有数据
      # 特点
        - **随机访问效率高:**可以通过下标直接访问任意元素,时间复杂度为O(1)
        - **存储密度高:**不需要额外的空间存储元素之间的逻辑关系
        - **插入删除效率低:**在中间位置插入或删除元素时,需要移动其后面大量元素,时间复杂度为O(n)
        - **空间固定:**需要预先分配固定大小的连续内存空间,可能造成空间浪费或溢出
        - **内存连续**
      # 顺序表有两类
        ## 静态分配的顺序表
        **用数组实现**，长度固定
        ## 动态分配的顺序表
        **用malloc函数申请内存空间，用指针访问，修改，删除，添加，**长度可扩展
      # 适用场景
      频繁读取/修改
      不经常插入删除（慢）

      定义+初始化
        ## 顺序表的实现——静态分配
          使用静态数组（固定大小的数组）叫静态分配
          ### 定义顺序表结构（结构体）
          ```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100 // 定义顺序表大小
typedef struct {
   int data[MAX_SIZE]; // 用数组存数据
   int length; // 顺序表当前长度
} SeqList;
          ```
          **速记：**
          **用结构体打包一个数组（存数据），一个变量（存顺序表当前长度）**

          ### 初始化顺序表（函数）
          - 需要将length变量（顺序表长度）赋为0
          - 需要将数组中的每个元素赋值为0（内存中有脏数据）（用一个for循环实现）
          ```c
void InitList (SeqList){
  for (int i=0; i<MaxSize; i++)
    L.data=0;
  L.length=0;
}
          ```
          速记：
          这是一个函数，执行：遍历数组并赋0，记录顺序表长度的变量赋0。
          ### 主函数
          ```c
int main(){
  SeqList L; //声明一个顺序表
  InitList(L); //初始化顺序表
  //...后续操作
  return 0;
}
          ```
    单链表
      # 描述
      单链表由一系列节点组成,每个节点包含数据域和指向下一个节点的指针域。链表中的节点在内存中不必连续存储,通过指针将各个节点串联起来。

      ![](assets/2c95a2dd-8276-81b8-9f9e-d39632ff10ef.jpg)
      （以上图为内存结构）
      # 内存特点
      不连续的内存
      # 节点结构
      数据+下一个节点的指针
      # 特点
      - **无需连续内存**: 链表的大小可以动态调整,无需预先分配固定的内存空间
      - **插入删除高效**: 插入删除只需要修改指针
      - **访问效率低**: 不支持随机访问,查找特定元素需要从头节点开始遍历,时间复杂度为O(n)
      - 只能单向查找
      # 分类
      ### 按有无头节点分：
      **带头节点的单链表**
      带头节点的单链表在链表的开始位置增加了一个不存储有效数据的头节点,头节点的指针域指向第一个实际存储数据的节点。
      **好处**：
      - 第一个节点不需要特殊处理
      **不带头结点的单链表**
      不带头节点的单链表直接从第一个存储有效数据的节点开始,没有额外的头节点。
      **坏处**：
      - 修改第一个节点需要修改整个链表的指针（整个链表的指针就是指向第一个节点的指针）
      ### 按循环与否分：
      **循环单链表**
      循环单链表的最后一个节点的指针域不指向NULL,而是指向头节点(或第一个节点),形成一个环形结构。这样可以从任意节点出发遍历整个链表。
      **非循环单链表**
      非循环单链表的最后一个节点的指针域指向NULL,表示链表的结束。这是最常见的单链表形式。
    双链表
      # 描述
      双链表每个节点包含三个部分:数据域、指向前一个节点的指针和指向后一个节点的指针。与单链表相比,双链表可以双向遍历,既能向前访问也能向后访问。
      ![](assets/2c95a2dd-8276-811b-8333-f21755f50896.jpg)
      # 内存特点
      不连续的内存
      # 节点结构
      上一个节点指针 + 数据 + 下一个节点指针
      # 特点
      - 可以双向遍历,提高了查找效率
      - 在已知某个结点的情况下，删除该结点不需要遍历找到其前驱，插入结点时，能直接同时调整前后指针
      - 占用更多内存空间,因为每个节点需要两个指针域
      # 分类
      按循环与否分：
      - 循环双链表:首尾相连,头节点的前驱指向尾节点,尾节点的后继指向头节点
      - 非循环双链表:头节点的前驱和尾节点的后继均为空指针
      按有无头节点分：
      - 带头节点的双链表:有一个不存储有效数据的头节点,便于统一处理插入和删除操作
      - 不带头节点的双链表:第一个节点即存储有效数据,操作时需要特殊处理边界情况
    循环链表
      # 介绍
      循环链表最后一个节点的指针域指向链表的第一个节点,形成一个环形结构。与普通单链表相比,循环单链表没有明确的"结束"标志,可以从任意节点出发遍历整个链表。
      ![](assets/2c95a2dd-8276-8108-8d57-ecb541499595.jpg)
      # 内存特点
      视情况而定，循环的静态链表是连续内存，循环的单/双链表内存不连续
      # 节点结构
      视情况而定如果是循环单链表与单链表一致，如果是循环双链表与双链表一致
      # 特点
      - **无明确尾节点**:最后一个节点指向头节点
      - **可从任意节点遍历整个链表**
      - **空表和非空表判定方式不同**：空循环链表：头指针为空，或头结点的 next 指向自身（视实现而定）
      # 分类
      按有无头节点分：
      根据是否使用头节点,循环单链表可以分为以下两种实现方式:
      - **带头节点的循环单链表**:设置一个不存储数据的头节点,头节点的 next 指向第一个数据节点,最后一个节点的 next 指向头节点
      - **不带头节点的循环单链表**:头指针直接指向第一个数据节点,最后一个节点的 next 指向第一个数据节点
      按单双链表分：
      - **循环单链表**:每个节点只有一个指针域,指向下一个节点,最后一个节点指向第一个节点
      - **循环双链表**:每个节点有两个指针域(前驱和后继),可以双向遍历,首尾节点相互连接形成环
    静态链表
      # 介绍
      静态链表是用数组来描述的链表结构,它把数组元素分为两个部分:数据域和游标域。数据域用来存储数据元素,游标域用来存储下一个元素的数组下标,从而模拟链表中的指针功能。这种数据结构在一些不支持指针的编程语言中特别有用,同时也便于实现内存的统一管理。
      ![](assets/2c95a2dd-8276-8154-83b3-d7b4de844b0e.jpg)
      PS：静态链表与其他链表不同，需要申请连续的内存空间
      PS：静态链表与顺序表的区别：
      顺序表按顺序存储（直接使用数组），
      静态链表虽然使用连续内存空间，但不按顺序存储（用数组+游标模拟指针）
      # 内存特点
      连续内存
      # 节点结构
      数据+游标（游标记录了下一个节点的数组下标）
      要点：
      如：静态链表的游标顺序：2-15613；数组第4个数是头节点
      代表按照：数组第四个→第六个→第三个→第五个→第一个→第二个  的顺序访问
      PS：**一般规定第一个节点（也就是数组下标为0）的节点为头节点，最后一个节点的游标为-1**
      # 特点
      - 使用数组实现,需要预先分配固定大小的存储空间
      - 通过游标(cur)来模拟指针,实现元素之间的逻辑链接
      - 插入和删除操作不需要移动大量元素,只需修改游标值
      # 分类
      ## 按存储方式分类
      - 单链静态链表:每个节点只包含一个游标,指向下一个节点
      - 双链静态链表:每个节点包含两个游标,分别指向前驱和后继节点
      ## 按功能分类
      - 备用链表:用于管理空闲节点,便于动态分配和回收
      - 数据链表:实际存储数据的链表结构
      ## 按是否循环分
      - 循环静态链表:最后一个节点的游标指向头节点,形成环形结构
      - 非循环静态链表:最后一个节点的游标为-1,表示链表结束
      # 备用链表
      使用静态数组：数组申请的空间是固定的，在插入等一系列操作完，会留下剩余未使用空间，将这些空间的下标组成一个静态链表，当需要插入一个节点时可以直接通过备用链表找到空闲位置
      PS：没有备用链表就只能遍历

    没看：
    初始化，销毁，插入，删除，按值查找，按位查找
    求表长，输出操作，判空
  栈与队列

    栈
      # 介绍
      栈(Stack)是一种遵循后进先出(LIFO, Last In First Out)原则的线性数据结构。它就像一摞盘子,只能从顶部添加或移除元素。
      只允许在一端插入/删除/修改
      ![](assets/2ca5a2dd-8276-81da-b50b-c82161341684.jpg)

      # 内存特点
      视情况而定：顺序栈使用数组，内存连续。链式栈用链表实现，内存不连续
      # 可访问性
      **只能访问/插入/删除栈顶**
      **不能访问中间**
      所以要操作某个指定数据，必须先将其上面数据弹出

      # 特点（人为规定）
      - 后进先出(LIFO):最后压入栈的元素最先被弹出
      - 只能在栈顶进行操作:所有的插入和删除操作都在栈顶进行
      - 访问受限:不能随机访问栈中的元素
      # 分类
      - 顺序栈:使用数组实现,容量固定或可动态扩展
      - 链式栈:使用链表实现,容量动态变化
    队列
      # 介绍
      队列(Queue)是一种先进先出(FIFO, First In First Out)的线性数据结构。它只允许在表的一端进行插入操作,而在另一端进行删除操作。
      ![](assets/2ca5a2dd-8276-8159-b8c4-c2c5c02c3f72.jpg)

      # 内存特点
      视情况而定，顺序队列/循环队列用数组实现，内存连续。链式队列用链表实现，内存不连续。
      # 可访问性
      **普通队列（链式队列/顺序队列）只能在**
      **队头：删除/访问**
      **队尾：插入**
      双端队列：队头队尾都能插入/访问/删除
      **队中间不可访问**
      # 特点
      1. **先进先出**（FIFO，First In First Out）最先进入队列的元素最先被删除与栈的“后进先出”相对
      1. **操作受限：**线性表只允许在队尾插入只允许在队头删除
      1. **有两个基本指针：**队头（front）：指向可删除元素队尾（rear）：指向可插入位置
      1. **不支持随机访问**：要访问对列中某个数据，要遍历
      # 分类
      - **顺序队列**:使用**数组实现**的队列,有固定大小
      - **链式队列:**使用**链表实现**的队列,大小动态变化
      - **循环队列**:用**数组实现**的队列，**顺序队列的改进**,解决"假溢出"问题
      - **双端队列**：用**双向链表**或**数组**实现，两端都能删除/插入/访问，但中间依旧不能访问
      ![](assets/2ca5a2dd-8276-8183-9c3e-e7accb01fc78.jpg)


      注意⚠️：多数人会误会的点：普通队列从头取，但与直觉不同的是，**队列不会自动往前**，会出现假溢出，循环队列解决了这个问题
      # 常见问题
      队头指针：指示队头的位置
      队尾指针：指示队尾的下一个位置
      队头队尾指针共用一套编号系统，也就是
      判空：队头指针==队尾指针
      判满（非循环队列）：队尾指针==队列容量
      判满（循环队列）：浪费一个单元
      ```plain text
(rear + 1) % MaxSize == front
      ```
      %maxsize是为了让前面的结果为正
    栈的初始化，进栈，出栈，销毁，读栈顶元素，判空没看
    栈在括号匹配中/求值中/递归中的应用，
    队列的应用
  树
    # 介绍
    树是一种非线性的数据结构，由节点（node）和边（edge）组成，具有层次关系。每个树结构都有一个根节点（root），从根节点出发可以到达树中的任何其他节点。树中除了根节点外，每个节点都有且仅有一个父节点，而每个节点可以有零个或多个子节点。
    ### 术语解释：
    **根节点：**
    树的最顶层节点
    **边：**
    连接两个节点的线段
    **叶子节点：**
    没有子节点的节点，位于树的最底层。
    **子树：**
    以某个节点为根的树
    **分支节点**（非叶子节点）**：**
    至少有一个子节点的节点
    **前驱：**
    遍历时，按遍历顺序，某节点的上一个节点
    **后继：**
    遍历时，按遍历顺序，某节点的下一个节点
    **父节点：**
    某节点的上级节点（不是遍历那个）
    **孩子节点：**
    某节点的下级节点（不是遍历那个）
    **兄弟节点：**
    具有相同父节点的节点
    **堂兄弟节点：**
    父节点不同，但在同一层级的节点
    **祖先节点：**
    从根节点到该节点路径上的所有节点（不包括该节点本身）
    **子孙节点：**
    某节点的所有子节点和其下属的所有节点
    **节点的层次（深度）：**
    从根节点到该节点的路径长度，根节点的层次为0或1（根据定义不同）（从上往下数）
    **节点的高度：**
    从下往上数
    **节点的度：**
    一个节点下的子节点数量
    **树的高度（深度）：**
    树中节点的最大层次数
    **树的度：**
    各节点度的最大值
    **路径长度：**
    经过几条边
    **路径：**
    从跟节点到某节点的路径
    **有序树：**
    树的子树顺序不能交换
    **无序树：**
    树的子树顺序可以交换
    **森林：**
    多个互不相交的树的集合，允许空森林
    **注意⚠️**
    **前驱：除了根结点外每个结点都有且只有一个前驱（否则就不是树结构）**
    **空树：根结点下没有一个节点就是空树**
    **子树：子树之间要求互不相交**
    **路径：单向的只能从上往下**
    # 树的常考性质
    节点的总数=节点的总度数+1
    ### N度的树 vs N叉树
    | N度的树 | N叉树 |
    | --- | --- |
    | 至少有一个n度的节点 | 所以节点最多有n度 |
    | 一定是非空树 | 可以是空树 |

    二叉树
      二叉树是有序树（左右顺序不能颠倒）
      # 二叉树的存储结构
        ## 顺序存储（用下标标记每个节点，从上到下，从左到右，从0开始，节点内不记录下标）
          ### 满二叉树
          二叉树的每一层都长满了节点
          ![](assets/2dd5a2dd-8276-81b6-a5ff-e9d2aaf7d417.png)
          特点：
          - 叶子节点都在最后一层
          - 不存在度为1的节点
          - 按层序从1开始编号，节点 i 的左孩子为 2i 右孩子为 2i+1 ，节点i的父节点为 i/2（如果有的话）
          ### 完全二叉树
          完全二叉树就是满二叉树去掉一部分（去掉某个编号的节点，其后面编号的节点也要去掉）
          ![](assets/2dd5a2dd-8276-811e-bc46-e185b338d0db.png)
          特点：
          - 只有最后两层可能有叶子节点
          - 最多只有一个度为1的节点
          - 按层序从1开始编号，节点 i 的左孩子为 2i 右孩子为 2i+1 ，节点i的父节点为 i/2（如果有的话）（与满二叉树一致）
          - 节点编号 ≤ n/2 的是分支节点，节点编号 > n/2 的是叶子节点
          **PS：如果完全二叉树某节点只有一个孩子，那一定是左孩子**
          ### 二叉排序树
          左子树的所有节点都比根节点小（左小）
          右子树的所有节点都比根节点大（右大）
          左子树和右子树又是一棵二叉排序树（分支也遵守）
          ![](assets/2dd5a2dd-8276-814e-8275-fffbe4a79743.png)
          ### 平衡二叉树
          树上任一左子树和右子树深度之差不超过1
          ![](assets/2dd5a2dd-8276-8138-89ff-d7eb03d6c342.png)
          PS：二叉平衡树避免了一边长一边短导致的某些数据搜索缓慢，某些又很快
        ## 链式存储（用指针表示节点间关系，一个节点分三个域，左孩子指针，数据域，右孩子指针）
      # 树的逻辑表示
        用广义表表示，规则如下：
        ```plain text
根节点（一层节点1（二层1，二层2），一层节点2（二层3，二层4））
        ```
        PS：二层的节点1，2 是一层节点1的子节点
        注意⚠️：括号表示法与广义表表示法相似，但括号表示法只能表示二叉树，且同一层顺序不能变
      # 树的遍历
        4种方法
        深度优先↓
        **先序遍历**：根左右（从上开始，有根先看根，根没了在看左，左没了在看右）
        （先记根，根记了再记左，左记了再记右）
        **中序遍历**：左根右（从左下开始，有左先看左，左没了在看根，根没了在看右）
        （先不记根，先记左，记完左再记上一级的跟，再记右）
        **后序遍历**：左右根（从左下开始，有左先看左，左没了看右，右没了看根）
        （先不记根，先记左，左记完在记右，右记完再记根）

        广度优先↓
        **层序**：从上到下，从左到右，按层输出
        **第一个括号的解释：“看”就是记录，看左/右都是看的下一层的左右**
        **第二个括号的解释：只要还有子节点，那这个节点就是根**
        前三种记录顺序：先深后广，最后一种顺序：先广后深
      # 线索二叉树
        是二叉树的改造，用于解决遍历到叶子节点时还要大量处理才能回到上一根节点的问题
        **它在节点中添加了两个域↓**
        **左标记域** | 左指针 | 数据域 | 右指针 |**右标记域**
        **用来指示左/右指针是线索指针还是孩子指针**
        **线索指针指向哪里取决于线索化时采用的遍历方法，指向该遍历方法的上和下一个节点**
      # 树的三种存储结构（注意是树，不是上面的二叉树）
        双亲表示法：用数组存储，每个节点两个域：数据域+父节点下标

        孩子表示法：用数组存储，每个节点两个域：数据域+该节点的孩子节点指针链表（不包含孙子节点）

        孩子兄弟表示法：每个节点分三个域：数据域+第一个孩子指针（从左到右）+下一个兄弟指针（该节点的兄弟，从左到右）
      # 树/森林转化成二叉树
        ### 树转化为二叉树（仅限于孩子兄弟表示法存储的树）
        第一个孩子节点=左孩子节点
        下一个兄弟节点=右孩子节点
        ### 森林转化成二叉树
        将第一个根节点作为根节点，其他根节点作为第一个根的兄弟节点
        第一个孩子节点=左孩子节点
        下一个兄弟节点=右孩子节点
        ### 反过来转化只需将等号左右对调
        略
      # 树/森林的遍历
        深度优先↓
        先根遍历：
        从根开始，将根记录下来，然后记录第一个子树，第一个子树记录完再记录第二个
        后根遍历：
        从根开始，先不记录根，记录完该分支最深的叶子节点在返回记录上一层的根

        广度优先↓
        层次遍历：从上到下，从左到右，按层输出

        森林遍历的前两种就是分别给每个树做先/后根遍历
        层次遍历：不能分别做，把所有树当一个树处理
      # 哈夫曼树
        哈夫曼树是一个压缩算法，数据存储在叶子节点中，其他分支称为内部节点
        ### 哈夫曼树的构造
        1. 得到带有权的值
        1. 将权最小的两个节点合并成一个新节点（权相加，值放一起）（贪心算法）
        1. 从剩下的节点和合成的节点中再选出最小的，合并……直到只剩一个树
        PS：**注意是从下往上构造的**
        ### 哈夫曼编码
        哈夫曼编码是一种前缀编码，通过哈夫曼树来实现数据的无损压缩。
        编码规则：从根节点到每个叶子节点的路径上**，****左分支标记为0，右分支标记为1**，路径上的0和1序列就是该叶子节点的编码。
        **ps：出现频率高的字符编码短，出现频率低的字符编码长，从而实现整体编码长度最短**。
        ### 带权路径长度
        这是用来评价压缩率的
        计算方法：
        $$
WPL=∑(叶子节点的权×该节点到根节点的路径长度)
$$
        求和是求所有节点的和
        ### 扩充二叉树
        扩充二叉树是在普通二叉树的基础上，为每个**空节点**（没有左孩子或右孩子的节点）添加一个**虚拟节点**，这样每个节点都具有两个子节点。通过这种方式，扩充二叉树将所有的“空节点”显式地表示出来。哈夫曼树是最优的扩充二叉树
      # 堆
        以完全二叉树的顺序存储结构来存储的一种特殊的二叉树。
        - **大根堆**：每个结点的值都大于或等于其左右子结点的值。
        - **小根堆**：每个结点的值都小于或等于其左右子结点的值。
  图
    # 基本术语
      - **权值**：边上的数值。
      - **网络**：边上带有权值的图。
      - **邻接顶点**：与某一顶点直接相连的顶点。
      - **子图**：从图中取出一部分作为子图
      **顶点的度（Degree of a Vertex）**：连接该顶点的边的数量。在无向图中，度是与该顶点连接的边的数目；在有向图中，度分为入度（in-degree）和出度（out-degree）。
      - **入度（In-degree）**：**是有向图的概念**，指向该顶点的边的数目。
      - **出度（Out-degree）**：**是有向图的概念，**从该顶点出发的边的数目。
      - **稠密图和稀疏图**
        - 稠密图：图中边数较多
        - 稀疏图：图中边数较少
      - **完全图**：每两个顶点之间都有边的图。
      - **联通图：**每两个节点间都有路径连接（注意不是边而是路径！）（只要求可达，不是全连接）
      - **路径**：顾名思义，就是沿着节点和边走的一条路线
      - **回路（Cycle）：**一条路径的起点和终点是同一个顶点。
      -  **简单路径**：除了起点和终点外，其余顶点不重复。
      - **简单回路**：回路+没有重复的顶点和边
      - **连通分量：是无向图的概念**，非连通图的极大连通子图。
      - **强联通图**：**是有向图的概念**，要求每个节点双向可达
      - **弱联通图**：**是有向图的概念，**忽略方向性后要求每个节点都可达
      - **强连通分量**：**是有向图的概念，**非强连通图的极大强连通子图。
      - **生成树：**包含所有顶点但不包含所有边的最小连通子图
    # **图的存储结构**
      ### 用邻接矩阵存储（二维数组）
        描述：用二维数组来表示节点间是否有连接，有N个节点就用 N*N 的二维数组
        例子：
        图如下
        ![](assets/2ee5a2dd-8276-8152-adc3-e2d0b38edd77.png)
        邻接矩阵如下⬇️
        |  | A | B | C | D | E |
        | --- | --- | --- | --- | --- | --- |
        | **A** | 0 | 1 | 0 | 1 | 0 |
        | **B** | 0 | 0 | 1 | 0 | 1 |
        | **C** | 0 | 0 | 0 | 0 | 0 |
        | **D** | 0 | 0 | 0 | 0 | 0 |
        | **E** | 0 | 0 | 0 | 1 | 0 |
        **无向图（不带权）：二维数组0表示没有边，1表示有边**
        **无向图（带权）**：**二维数组0表示没有边，有边的位置填权的值**
        **有向图（不带权）：与无向图一致**
        **有向图（带权）：与无向图一致**
        PS：无向图的邻接矩阵的上三角和下三角是对称的，有向图不对称
        优缺点
        **优点：**
        - 直观，易于理解和实现
        - 方便判断两个顶点之间是否有边
        - 方便计算各个顶点的度（对于无向图，第i行或第i列非零元素的个数就是顶点i的度；对于有向图，第i行非零元素个数是出度,第i列非零元素个数是入度）
        **缺点：**
        - 空间复杂度高，为O(n²)，不适合存储稀疏图
        - 不便于增加和删除顶点
        - 空间占用多
      ### 用邻接表存储
        描述：图的每个顶点都有一个单独的链表或动态数组，用来存储与该顶点相连的所有邻接顶点。
        例子：无向图如下
        ![](assets/2ee5a2dd-8276-8103-961a-f2d49d4f99c0.png)
        邻接表是下面这几个链表⬇️
        链表A：B➡️C
        链表B：D➡️A
        链表C：A➡️D
        链表D：B➡️C
        **但  **这不是标准写法，只是帮助理解
        正确写法如下
        | 顶点 | 邻接点 |
        | --- | --- |
        | **A** | B, C |
        | **B** | A, D |
        | **C** | A, D |
        | **D** | B, C |
        **无向图（不带权）的邻接表：每个顶点的链表包含这个节点的所有邻接节点**
        这么写：

        | 顶点 | 邻接点 |
        | --- | --- |
        | 节点0 | 节点1 , 节点2 |
        | … | … |
        无向图（带权）
        这么写：

        | 顶点 | 邻接点 |
        | --- | --- |
        | 节点0 | （节点1 , 权值）→ （节点2 ，权） |
        | … | … |

        **有向图（不带权）的邻接表：每个顶点的链表****只包含正确方向的****所有邻接节点**
        写法没有不同

        **有向图（带权）：一样**
        略

        优缺点：
        **优点：**
        - 空间复杂度低，适合存储稀疏图，空间复杂度为O(|V|+|E|)
        - 便于找到某个顶点的所有邻接顶点
        - 便于增加和删除顶点
        - 占用空间小
        **缺点：**
        - 不便于判断两个顶点之间是否有边，需要遍历链表
        - 不便于计算有向图的入度（需要遍历整个邻接表）
      ### 邻接多重表
        这个比较复杂且不好用图形和文字描述
        直接记要点⬇️

        **一、一句话定义（必背）**
        > 邻接多重表：
          一种用于**无向图**的存储结构，
          **每条边只存一次**，
          但**同时被两个顶点共享**。

        👉 **考试最爱问：**
        > “邻接多重表的优点是什么？”
          答：**避免无向边重复存储，便于删边**

        **三、结构组成（会写名词就行）**
        1️⃣ 顶点结点包含：
        - 顶点信息
        - 指向第一条边的指针
        2️⃣ 边结点包含：
        - 两个顶点下标（ivex、jvex）
        - 两个指针（分别链接这两个顶点的边链）
        - 边的权值（若有）
        ⚠️ **关键词：**
        - 一条边 → 一个边结点
        - 两个指针 → 连两个顶点

        六、考试答题万能模板（直接套）
        邻接多重表是一种无向图的链式存储结构。
          每条无向边在表中只设一个边结点，
          该边结点同时被其两个端点的边链表所共享。
          与邻接表相比，邻接多重表避免了边的重复存储，
          便于对边进行删除等操作。

          解决了两个节点间不能有多个边，和重复存储的问题
      ### 十字链表
        这个也恶心
        直接记要点
        **十字链表：简单定义**
        十字链表：
        一种存储**有向图**的链表结构，
        每条边在**出度链表**和**入度链表**中各存一次。
        它解决了**有向图边的反向存储问题**。
        **主要结构**
        1. **顶点链表**：每个顶点有两个指针：
          - **出度指针**：指向从该顶点出发的边。
          - **入度指针**：指向指向该顶点的边。
        1. **边链表**：每条边结点存储：
          - **源顶点**（ivex）
          - **目标顶点**（jvex）
          - **出度指针**（olink）指向下一条出边
          - **入度指针**（ilink）指向下一条入边
        **关键特点**
        1. **每条边存两次**，分别在出度链表和入度链表中。
        1. **适用于有向图**，特别是稀疏图。
        1. **查询和删除边**方便（时间复杂度 (O(1))）。
        **总结**
        - **十字链表**是**有向图**的存储结构，每条边在两个链表（出度和入度）中分别存储一次。
        - 适合**稀疏图**，查找和删除边很高效。
    # **图的遍历**
      - **深度优先搜索 DFS**
      - **广度优先搜索 BFS**
  串
    # 介绍
    串(String)就是字符串，必须由字符组成，记为S=’a_1a_2a_3…..’
    # 特性
    - 串的长度:串中字符的个数,记为|S|
    - 空串:长度为0的串,不包含任何字符
    - 子串:串中任意个连续字符组成的子序列
    - 主串：子串的上级串
    - 子串在主串中的位置：子串的第一个字符在主串的位置
    注意⚠️：
    1. 串与数组不同从1开始而不是0
    1. 空格也是字符不是空串
    # 存储结构
    如果用数组存，内存连续
    如果用链表存，内存不连续
    # 分类
    链式串：用链表实现
    顺序串：用数组实现（常见）

    匹配算法（未完）（要求完全匹配上）
      说明：在主串中找到待匹配的字符串（模式串）
      如：
      主串：abcdefg
      模式串：efg
      目的：在主串中找到模式串“efg”
      **注意⚠️：**
      1. **模式串与子串不同，模式串是“待匹配串”主串中不一定有，子串隶属于主串所以主串中一定有。**
      1. 子串必须连续（不能跳着选几个字符）
      # 朴素模式匹配算法
      思路：从主串的第一个字符开始，依次与模式串进行比较，如果匹配失败则从主串的下一个字符重新开始匹配。
      **原理：用主串的所有与模式串长度相同的子串和模式串做对比**
      时间复杂度：O(m*n)，其中m为主串长度，n为模式串长度。
      例：
      主串：18269251
      模式串：25
      匹配逻辑：（m是模式串长度）
      1=2→失败，主串扫描指针回朔m-1位
      8=2→失败，主串扫描指针回朔m-1位
      （2=2→成功，6=5→失败）→失败
      …..
      （2=2→成功，5=5→成功）→成功
