---
{
  "id": "1e75a2dd-8276-8087-84be-d2c43b6035a6",
  "url": "https://www.notion.so/C-1e75a2dd8276808784bed2c43b6035a6",
  "created_time": "2025-05-02T05:10:00.000Z",
  "last_edited_time": "2025-09-24T08:45:00.000Z"
}
---

# 🙃 C语言进阶

### 
[数组](数组/index.md)
  # 数组
  1. 当使用scanf给数组输入值时无需取地址符
  因为：数组名本身就是一个指向数组首元素的指针，且数组在内存中连续存储
  例如：
  ```c
char password[];
scanf("%s",password);
  ```
  ‍
[scanf特性（未完）](scanf特性未完/index.md)
  # scanf特性（未完）
  ## 缓冲输入
  scanf 使用输入缓冲区来存储输入的数据。当调用 scanf 时，它从缓冲区中读取数据，而不是直接从输入设备读取。
  ‍
  ## 阻塞调用
  scanf 是一个阻塞函数，这意味着如果输入缓冲区为空，程序将暂停执行，等待用户输入数据。
  ‍
  ‍
  ‍
  ## 错误处理
  当使用`scanf`函数进行输入时，如果输入的字符不符合格式控制符指定的类型，`scanf`的行为将取决于具体的格式控制符和输入情况。以下是一些常见的情况：
  1. **整数输入（错误不输入）** ：
    - 如果输入的不是有效的整数（例如，输入了字母或特殊字符），`scanf`将无法解析该输入，并且输入将被留在输入缓冲区中，等待下一次输入调用读取。
  1. **浮点数输入（错误不输入）** ：
    - 如果输入的不是有效的浮点数（例如，输入了字母或特殊字符），`scanf`将无法解析该输入，并且输入将被留在输入缓冲区中。
  1. **字符输入（对不对都输入）** ：
    - 对于`%c`格式控制符，`scanf`将读取下一个字符，无论它是什么。这意味着即使是不符合预期的字符也会被读取。
  1. **字符串输入（遇到空格，空白字符，制表符，换行符停止）** ：
    - 对于`%s`格式控制符，`scanf`将读取直到遇到空白字符（空格、制表符或换行符）为止的字符串。如果输入包含空白字符，`scanf`将停止读取，并将剩余的输入留在缓冲区中。
  1. **不匹配的输入**：
    - 如果输入的字符不符合格式控制符指定的类型，`scanf`将返回一个值，表示成功读取的输入项的数量。如果返回值小于预期的输入项数量，表示有输入项未成功读取。
  1. **缓冲区中的剩余输入**：
    - 如果`scanf`无法解析输入或只部分解析了输入，未解析的输入将留在输入缓冲区中，可能会影响后续的输入调用。
  ‍
  # scanf读取到空格停止/scanf读取跳过部分字符
  scanf() 函数读到空格就停止读取的现象，主要与格式说明符的使用方式有关（例如 %s、%d 等）

   一、基础数据类型控制符
  1. %d  %u  %x  %o   
  行为：（整数）自动跳过前导空白字符（空格、换行符、制表符），直到遇到非数字字符时停止输入
  
2. %f  %lf  %e
  行为：（浮点）跳过前导空白字符，遇到非数字或指数符号外的字符终止。     
  注意：%lf`在scanf中是必需的（与printf不同），否则可能因类型不匹配导致错误
  
3. %c     
  行为：（字符），不跳过任何空白字符，包括空格和换行符。
  若需跳过前导空白，需在%c前加空格
   
4. %s  
  行为：（字符串）遇到空白字符即终止，并在末尾自动添加空字符`\0`。需确保目标数组足够大以避免溢出

二、高级格式控制符
  5. %[]
  （扫描集合）
  行为：按自定义字符集合匹配输入。
  %[a-z]表示仅接收小写字母
  %[^\n]表示读取到换行符前所有字符（含空格）   
  
6. %*
  （抑制赋值）
  行为：跳过匹配的输入字段，常用于忽略不需要的部分。    
  
7. 宽度限定符
  （如`%5d`）
  行为：限制读取的字符数量，防止溢出或截断无效数据。     
  
8. 长度修饰符
  （如`%ld` / `%hd`）
  行为：指定数据类型长度。`%ld`读取`long int`，`%hd`读取`short int`。     - **注意**：长度修饰符必须与变量类型严格匹配。
---
 三、特殊场景与陷阱**- **混合输入问题**：    当数值型（如`%d`）与字符型（如`%c`）控制符混合使用时，**残留的换行符可能导致意外读取**。需用`while (getchar() != '\n');`清空缓冲区。
- **非格式字符匹配**：    格式字符串中的非格式字符（如逗号）需与输入严格匹配，否则导致解析失败。    ```c  scanf("Value:%d", &num);  // 输入必须为"Value:123"，否则匹配失败
[特性](特性/index.md)
  # 特性
  ‍
[结构体（自定义数据类型）](结构体自定义数据类型/index.md)
  可以理解为能存储多种数据类型的数组（不严谨）
  **事实上是创建了一个名为 “struct 结构体名” 的数据类型，因此在重命名时需要带struct**
  **结构体不存储数据，数据存储在结构体变量中，所以结构体变量与正常变量的定义和调用无异**
  把结构体就当自定义数据类型处理，结构体变量就当该类型的变量处理（别听什么比喻，都会出错）
  ## 声明：
  ```c
struct 结构体名
{
成员列表；//存放该结构体的属性（每个下辖变量的属性）
}
变量列表；//变量列表声明改结构体下辖的变量，用逗号隔开
  ```
  ![](assets/20a5a2dd-8276-801b-a3d0-ceac9e128e8c.jpg)
  也可以：
  先声明好结构体的属性
  再声明结构体变量
  用这个：
  ```c
struct 结构体名 变量1，变量2;
  ```
  ps：变量列表不只可以定义变量，还可以定义 指针,数组 等
  ## 匿名结构体类型
  ps：如果没给结构体命名就是“匿名结构体类型”：
  后续无法为结构体添加变量（因为该结构体无名字）
  ## 访问结构体成员
  与数组不同，结构体不是通过下标访问的，而是通过变量名.成员名（结构体变量名）访问
  例
  ```c
结构体变量名.成员名=1
  ```

  ## 访问结构体
  像调用变量一样直接调用变量列表中的变量
  ## 注意事项
  牢记结构体有成员列表和变量列表，
  **访问结构体成员用的是变量列表**
  **添加结构体变量用的是结构体名**
  **如果结构体没有定义变量列表，则需要使用: struct+结构体名 的方式调用**
  也可以使用 typedef struct 结构体名 变量名 来重命名该数据类型的类型名（以方便使用），**注意⚠️：typedef并非是添加/修改变量列表**
  ```c
struct 结构体名{
  成员列表；
}
/*结构体没有定义变量列表*/
struct 结构体名.成员列表

  ```

  ## 结构体数组
  结构体数组就是由多个相同类型的结构体组成的数组
[for循环](for循环/index.md)
  for循环的判断部分省略意味着条件恒成立
[输入输出缓冲区](输入输出缓冲区/index.md)
  # 输入输出缓冲区
  有缓冲输入：
  1. scanf与getchar从输入缓冲区读取字符
  若输入缓冲区无字符则程序暂停等待字符输入
  1. 当用户输入字符串并敲下回车后缓冲区也将换行符存入了
  scanf读取缓冲区中的哪些字符取决与scanf后的格式控制符
  缓冲区中未被scanf读取的部分会继续留在缓冲区中
  例子：
  ```c
char arr[]；
scanf（“%s”，arr）；
  ```
  以上示例表明scanf只会读取字符串
  ‍
  ## 清空缓冲区
  为了防止缓冲区中未读取的字符干扰程序运行，有时候我们需要清空缓冲区
  1. 方法一：使用getchar循环读取直到EOF标识
    ```c
while ((ch = getchar()) != EOF);
    ```
  ‍
[函数参数的传递的问题](函数参数的传递的问题/index.md)
  PS：
  函数间默认数据不互通
  传入的参数只是原数据的拷贝
  在函数内直接修改的是数据的拷贝
  ![](assets/2255a2dd-8276-80e5-89d7-e46a0da5a4ac.png)
  以下是将函数中修改值同步至其他函数的方法
  ## 函数参数传出方法 
  ### 1.用返回值传回调用位置（一个值）
  ```c
return 要回传的变量;
  ```
  这种方法只能回传一个值
  ### 2.用全局变量
  如
  ```c
#include<stdio.h>
int a;// 定义全局变量a

int hanshu(b)
{
a=b+1;
}

int main()
{
hanshu(3);// hanshu是函数名
printf("%d",a);
return 0;
}


  ```
  定义了全局变量该变量即可在所有函数间互通
  ### 3.用指针传参
  用指针直接在原始变量的地址上操作
  要用到：[给指针赋带取地址符（&）的表达式，就是修改指针存储的地址（相当于写入模式）](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2245a2dd8276808c84d2efed69f657b3) [给指针直接赋值，就是修改指针指向元素的值（相当于只读模式）](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2245a2dd827680ce883fc6c3393ee93f) 
  步骤：
  1. 定义指针
  1. 获取原变量地址（在函数外）
  1.
[指针高级](指针高级/index.md)
  # 总结的总结
  ***p有两部分**
  **p用来存放地址**
  ***代表“指过去”**
  **&代表取地址，在指针中并非代表取指向的地址，而是指针的地址**
  **带*访问的是被指向的元素**
  **不带*访问的是地址**
  **带&访问的是指针的地址**
  #######################################################################################
  Q：为什么指针的定义需要定义数据类型
  A：对于指向一个已经定义了数据类型的元素来说可能没意义，但对于直接指向某一内存区域来说起到了如何解码（按int解码还是float）的作用
  ## 指针使用（指针的计算）
  ### 指针的取内容运算
  ### 注意事项
  *是解引用符
  不能直接对一个变量进行解引用，因为该变量不是指针变量（不是“int *”类型）
  要先定义一个指针变量，再对要使用的变量取地址，再赋给指针变量
  &是取地址符
  ### 总的来说
  指针是一个地址容器
  以下是一个用指针修改数据的例子：
  1. 初始化一个变量
  ```c
int a=1;
  ```
  1. 定义一个指针变量
  ```c
int *p;
  ```
  1. 将变量的地址存入指针（操作指针地址不带*，除非初始化）
  ```c
p=&a;
  ```
  1. 用指针修改变量值
  ```c
*p=100;
  ```
  1. 修改完成！

  **总结：**
  指针用赋值来使用
  <u>**给指针赋带取地址符（&）的表达式，就是修改指针存储的地址（相当于写入模式）**</u>
  <u>**给指针直接赋值，就是修改指针指向元素的值（相当于只读模式）**</u>
  **指针是个容器，要先填充容器（将其他元素的地址赋给指针），再使用**
  未存入地址的指针叫空指针（存了一个随机地址）

  ### 指针的++/－－
  指针++：指针的内存地址向后一个单位（并非指针指向的元素+1）（并非移动一个字节）（移动的内存地址<u>**字节数取决于被指向的元素的数据类型**</u>）
  指针－－：……向前移动……
  ```c
p1++；
p2－－；
//p1,p2为指针
  ```
  上面指针不加*因为：[但要调用/修改指针所存的的地址则不带*号](https://www.notion.so/1f15a2dd827680d190efcdc614e6d087#20f5a2dd82768001a131ec778ae7712c) 

  ### 指针的比较/算术运算
  **>,<,==,! = :比较地址谁大谁小还是相等**（同样不带*，因为比较的是地址）
  **－，+：+1就是在内存地址加一个单位的字节数（一个单位的字节数取决于所指向的元素的数据类型）**
  ## 指针类型
  ps：除了整形，字符型，浮点型等常见类型外还有指针型，定义指针时用的数据类型就是指针型
  ### 基本指针类型
[动态内存分配](动态内存分配/index.md)
  <u>***这些功能基于<stdlib.h>标准库头文件***</u>
  一般的变量（全局变量除外）和运行中产生的**数据会默认放在栈区中**，如果给数组定义空间太大可能会栈溢出，且内存空间大小固定，不灵活
  所以可以用动态内存分配，**分配的内存在堆区**
  ### malloc函数
  ```c
malloc(字节数);//申请若干字节内存
  ```
  **malloc函数的返回值是内存起始指针，异常返回NULL**（上面只申请了内存但未接收地址）
  完整例子（申请后立即存入一个指针中）
  ```c
int *p;
p=malloc(字节数);
  ```
  ### free函数（释放）
  释放分配的空间，free函数的参数是要释放内存的首地址
  ```c
free(地址);
  ```
  ### calloc函数(分配并格式化)
  calloc函数参数有两个：分配大小，分区个数
  calloc将分配的内存区域全写0，并分区
  返回值是是起始地址指针，或NULL（失败）
  ```c
calloc(字节数,分区数);
  ```
  完整例子：
  ```c
int *p;
p=calloc(字节数,分区数);
  ```
  ### realloc函数（修改已分配空间大小）
  realloc函数要两个参数：已分配空间首地址，修改后大小
  返回值：修改后空间首地址，或NULL（失败）
  ```c
realloc(首地址,字节数);
  ```
  ## 访问申请的内存
  1. 直接将以上函数定义在数组的定义中
  ```c

  ```
  2.用指针
[链表](链表/index.md)
[结构体（重构）](结构体重构/index.md)
  **C语言都是先声明后定义**
  # 声明部分
  ### 先声明结构体成员列表

  ```c
struct 结构体名
{
成员列表；
}；
  ```
  ### 或直接初始化
  ```c
struct 结构体名
{
成员列表；
}变量列表；
  ```
  # 使用部分
  ### 添加变量列表 方法1:使用结构体名添加变量列表（要带struct）
  ```c
struct 结构体名 变量名1，变量名2；
  ```
  ### 添加变量列表 方法2:使用typedef
  ### 使用变量名+.访问成员列表
  ```c
变量名.成员名
  ```
  如
  ```c
printf(＂%d\n＂,变量名.成员名)
  ```
[动态内存管理](动态内存管理/index.md)
  ## malloc（开辟自定义个字节的内存空间）
  malloc的返回值是指针
  **malloc需要强制类型转换成要存储的数据的类型（需要转换成指针型，如int*，float*，用int则malloc的返回值会丢失指针的属性）**
  用法：
  将malloc赋给一个指针
  ```c
数据类型*指针变量名=（数据类型*）malloc（字节大小）
  ```
