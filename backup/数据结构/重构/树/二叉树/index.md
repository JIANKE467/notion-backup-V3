---
{
  "id": "2dd5a2dd-8276-8159-ad9a-f0b9a6da41a5",
  "url": "https://www.notion.so/2dd5a2dd82768159ad9af0b9a6da41a5",
  "created_time": "2026-01-03T07:06:00.000Z",
  "last_edited_time": "2026-01-07T14:55:00.000Z"
}
---

#  二叉树

二叉树是有序树（左右顺序不能颠倒）
# 二叉树的存储结构
  ## 顺序存储（用下标标记每个节点，从上到下，从左到右，从0开始，节点内不记录下标）
    ### 满二叉树
    二叉树的每一层都长满了节点
    ![](assets/2dd5a2dd-8276-81b6-a5ff-e9d2aaf7d417.png)
    特点：
    - 叶子节点都在最后一层
    - 不存在度为1的节点
    - 按层序从1开始编号，节点 i 的左孩子为 2i 右孩子为 2i+1 ，节点i的父节点为 i/2（如果有的话）
    ### 完全二叉树
    完全二叉树就是满二叉树去掉一部分（去掉某个编号的节点，其后面编号的节点也要去掉）
    ![](assets/2dd5a2dd-8276-811e-bc46-e185b338d0db.png)
    特点：
    - 只有最后两层可能有叶子节点
    - 最多只有一个度为1的节点
    - 按层序从1开始编号，节点 i 的左孩子为 2i 右孩子为 2i+1 ，节点i的父节点为 i/2（如果有的话）（与满二叉树一致）
    - 节点编号 ≤ n/2 的是分支节点，节点编号 > n/2 的是叶子节点
    **PS：如果完全二叉树某节点只有一个孩子，那一定是左孩子**
    ### 二叉排序树
    左子树的所有节点都比根节点小（左小）
    右子树的所有节点都比根节点大（右大）
    左子树和右子树又是一棵二叉排序树（分支也遵守）
    ![](assets/2dd5a2dd-8276-814e-8275-fffbe4a79743.png)
    ### 平衡二叉树
    树上任一左子树和右子树深度之差不超过1
    ![](assets/2dd5a2dd-8276-8138-89ff-d7eb03d6c342.png)
    PS：二叉平衡树避免了一边长一边短导致的某些数据搜索缓慢，某些又很快
  ## 链式存储（用指针表示节点间关系，一个节点分三个域，左孩子指针，数据域，右孩子指针）
# 树的逻辑表示
  用广义表表示，规则如下：
  ```plain text
根节点（一层节点1（二层1，二层2），一层节点2（二层3，二层4））
  ```
  PS：二层的节点1，2 是一层节点1的子节点
  注意⚠️：括号表示法与广义表表示法相似，但括号表示法只能表示二叉树，且同一层顺序不能变
# 树的遍历
  4种方法
  深度优先↓
  **先序遍历**：根左右（从上开始，有根先看根，根没了在看左，左没了在看右）
  （先记根，根记了再记左，左记了再记右）
  **中序遍历**：左根右（从左下开始，有左先看左，左没了在看根，根没了在看右）
  （先不记根，先记左，记完左再记上一级的跟，再记右）
  **后序遍历**：左右根（从左下开始，有左先看左，左没了看右，右没了看根）
  （先不记根，先记左，左记完在记右，右记完再记根）

  广度优先↓
  **层序**：从上到下，从左到右，按层输出
  **第一个括号的解释：“看”就是记录，看左/右都是看的下一层的左右**
  **第二个括号的解释：只要还有子节点，那这个节点就是根**
  前三种记录顺序：先深后广，最后一种顺序：先广后深
# 线索二叉树
  是二叉树的改造，用于解决遍历到叶子节点时还要大量处理才能回到上一根节点的问题
  **它在节点中添加了两个域↓**
  **左标记域** | 左指针 | 数据域 | 右指针 |**右标记域**
  **用来指示左/右指针是线索指针还是孩子指针**
  **线索指针指向哪里取决于线索化时采用的遍历方法，指向该遍历方法的上和下一个节点**
# 树的三种存储结构（注意是树，不是上面的二叉树）
  双亲表示法：用数组存储，每个节点两个域：数据域+父节点下标

  孩子表示法：用数组存储，每个节点两个域：数据域+该节点的孩子节点指针链表（不包含孙子节点）

  孩子兄弟表示法：每个节点分三个域：数据域+第一个孩子指针（从左到右）+下一个兄弟指针（该节点的兄弟，从左到右）
# 树/森林转化成二叉树
  ### 树转化为二叉树（仅限于孩子兄弟表示法存储的树）
  第一个孩子节点=左孩子节点
  下一个兄弟节点=右孩子节点
  ### 森林转化成二叉树
  将第一个根节点作为根节点，其他根节点作为第一个根的兄弟节点
  第一个孩子节点=左孩子节点
  下一个兄弟节点=右孩子节点
  ### 反过来转化只需将等号左右对调
  略
# 树/森林的遍历
  深度优先↓
  先根遍历：
  从根开始，将根记录下来，然后记录第一个子树，第一个子树记录完再记录第二个
  后根遍历：
  从根开始，先不记录根，记录完该分支最深的叶子节点在返回记录上一层的根

  广度优先↓
  层次遍历：从上到下，从左到右，按层输出

  森林遍历的前两种就是分别给每个树做先/后根遍历
  层次遍历：不能分别做，把所有树当一个树处理
# 哈夫曼树
  哈夫曼树是一个压缩算法，数据存储在叶子节点中，其他分支称为内部节点
  ### 哈夫曼树的构造
  1. 得到带有权的值
  1. 将权最小的两个节点合并成一个新节点（权相加，值放一起）（贪心算法）
  1. 从剩下的节点和合成的节点中再选出最小的，合并……直到只剩一个树
  PS：**注意是从下往上构造的**
  ### 哈夫曼编码
  哈夫曼编码是一种前缀编码，通过哈夫曼树来实现数据的无损压缩。
  编码规则：从根节点到每个叶子节点的路径上**，****左分支标记为0，右分支标记为1**，路径上的0和1序列就是该叶子节点的编码。
  **ps：出现频率高的字符编码短，出现频率低的字符编码长，从而实现整体编码长度最短**。
  ### 带权路径长度
  这是用来评价压缩率的
  计算方法：
  $$
WPL=∑(叶子节点的权×该节点到根节点的路径长度)
$$
  求和是求所有节点的和
  ### 扩充二叉树
  扩充二叉树是在普通二叉树的基础上，为每个**空节点**（没有左孩子或右孩子的节点）添加一个**虚拟节点**，这样每个节点都具有两个子节点。通过这种方式，扩充二叉树将所有的“空节点”显式地表示出来。哈夫曼树是最优的扩充二叉树
# 堆
  以完全二叉树的顺序存储结构来存储的一种特殊的二叉树。
  - **大根堆**：每个结点的值都大于或等于其左右子结点的值。
  - **小根堆**：每个结点的值都小于或等于其左右子结点的值。
