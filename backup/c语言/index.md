---
{
  "id": "3005a2dd-8276-8184-9d06-f3f4599e8a0a",
  "url": "https://www.notion.so/c-3005a2dd827681849d06f3f4599e8a0a",
  "created_time": "2026-02-07T09:52:00.000Z",
  "last_edited_time": "2026-02-26T02:37:00.000Z"
}
---

# ©️ c语言

[#define定义常量和宏](define定义常量和宏/index.md)
  # #define定义常量和宏
  ## #define声明宏
  可以理解为简易版函数
  声明语法：
  ![](assets/3005a2dd-8276-8197-bd03-fa7dca65ce4c.png)
  IMG_20250409_162349
  使用时用 宏体 替代 宏名 与 宏参
  ```c
#define 宏名(宏参) 宏体
  ```
  注意：
  宏名与宏参之间没有空格
  宏只做字符的替换（原理），不会加任何括号（参见书p149－6.26）
  宏的参数受括号保护
  ### 宏的使用
  ps：
  形参：定义宏时括号内的参数（被替换的参数）
  实参：使用宏时括号内的参数（替换别人的参数）
  宏展开：形参被替换的过程叫宏展开
  ```c
a=3+S(5,8)//其中S(5,8)是宏
  ```
  ### define定义常量
  语法：
  ```c
#define 常量名 常量值
  ```
  ‍
[C 基础语法](c-基础语法/index.md)
  # C 基础语法
  在 C 语言中，令牌（Token）是程序的基本组成单位，编译器通过对源代码进行词法分析，将代码分解成一个个的令牌。C 语言的令牌主要包括以下几种类型：
  1. 关键字（Keywords）
  1. 标识符（Identifiers）
  1. 常量（Constants）
  1. 字符串字面量（String Literals）
  1. 运算符（Operators）
  1. 分隔符（Separators）
  ‍
[C语言关键字](c语言关键字/index.md)
  # C语言关键字
  ## 以下关键字均为C语言内置
  break：跳出循环/switch分支
  const:常属性：
  用于声明一个常量，即其值在初始化后不能被修改。const可以提高程序的可读性和维护性，同时还可以避免程序中的意外修改。
  示例
  ```c
const int MAX_SIZE = 100;
  ```
  continue：跳过本次循环
  default：用于switch分支，表示当没有任何 case 匹配时，default 子句会被执行。
  if 和else：分支
  for：循环
  do和 while：循环
  enum：枚举
  struct：结构体
  union：联合体
  void：空
  typedef：创建类型别名
  switch和case：多分支
  goto：跳转
  ```c

goto 标识符;
// 其他语句
标识符:
// 跳转后要执行的语
  ```
  ‍sizeof：查看大小

  char 字符
  short 短整型
  int 整形
  double 浮点（双精度）
  float 浮点（单精度）
  ‍return：返回值
[函数](函数/index.md)
  # 函数
  ‍
  函数的定义语法：
  ```c
函数名（函数参数）
{
  函数体；
}
  ```
  ‍
  注意：定义函数时，不需给函数头后加分号。
  使用函数时，需要给函数后加分号
  ‍
  ## 注意：
  函数的参数是函数的输入
  函数的返回值“return”是函数的输出
  **函数必须有输入必须有输出（非void类型的函数不定义返回值，会返回随机值）**
  如果函数不需要输出，一定要将函数定义为void类型
  函数不能嵌套定义，可以嵌套调用


  函数传参问题看这个[函数参数的传递的问题](https://www.notion.so/2245a2dd827680b6be99fb13c540050f)
[分支](分支/index.md)
  # 分支
  # if语句
  **注意⚠️if语句后不跟分号**
  ```c
             **⚠️如果if后要跟多个语句，则需要                   将这些语句用花括号括成一个代                       码块**
  ```
  示例
  ```c
#include <stdio.h>
int main()
{
    if (3 == 5)
    printf("字符串\n");
    return 0;
}
  ```
  if只能执行一种情况（单分支）
  ### 格式
  ```c
if (表达式)
执行语句
  ```
  或者
  ```c
if(表达式)
{
 执行语句1;
 执行语句2；
 ...
}
  ```
  # if else语句
  示例
  ```c
#include <stdio.h>
int main()
{

 if(3==5)
   { printf("字符串1\n");}
 else
   { printf ("字符串2\n";)
 return 0;
}
  ```
  **注意⚠️if 与else后都不跟分号**
  同理if else分支内只有一个语句则不需要大括号括起，有多个语句则需要用大括号括成一个代码块
  我们建议不论有无多个语句都用大括号括起以提升可读性
  if else 可以处理两种情况（双分支）
  如果要用 if else语句 处理多分支需要嵌套使用
  ### 编译器处理if else嵌套规则
  - 每个else语句都与最近的一个未配对的if语句配对（从内向外配对）
  - 如果在if if else 嵌套语句中想实现第一个if与else配对，则需要用花括号括起第二个if语句，否则默认第二个if与else配对
  ### 格式
  ```c
if (表达式)
  {执行语句1;}
else
  {执行语句2;}
  ```
  # switch 语句
  示例
  ```c
#include <stdio.h>
int main ()
{
  /* 局部变量定义 */
  char grade = 'B';
  switch(grade)
  {
    case 'A' :
       printf("很棒！\n" );
    break;

    case 'B' :
    case 'C' :
       printf("做得好\n" );
    break;

    case 'D' :
       printf("您通过了\n" );
    break;

    case 'F' :
       printf("最好再试一下\n" );
    break;

    default :
       printf("无效的成绩\n" );
  }
printf("您的成绩是 %c\n", grade );
return 0;
}
  ```
  **注意⚠️示例中第12-15行表示B与C分支共用一个代码块**
  每个case后不加break即默认与下一个case一起执行
  case（实例）：后跟一个常量值，当表达式的值与该值相匹配，执行该case后面的代码块。
  break（终止）：终止Switch语句的执行。执行到break，程序会跳出Switch语句。
  default（不匹配）：所有case都不匹配，执行default后面的代码块。
  如果没有default且没有匹配的case：则不执行任何操作。
  ### 格式
  ```c
switch (整形表达式)
{
  语句项：
}
  ```
  ```c
语句项是：
//是一些case语句
//如下
case 整形常量表达式：
  语句；
  ```
  注意⚠️：switch只能处理整形
  由于字符也是用整形存储，因此这里的整形表达式也可以是字符
  ‍
[循环](循环/index.md)
  # 循环
  # 说在最前面：
  在循环中
  **零为假非零为真**
  其他表示真假的方法：布尔变量
  但需引入 stdbool.h 头文件才能使用
  布尔变量使用true和false表示对和错（分别对应非0与0）
  ```c
#include <stdio.h>
#include <stdbool.h> // 引入布尔类型
int main()
{
  bool isHappy = true; // 定义布尔变量并初始化为true
  bool isSad = false;  // 定义布尔变量并初始化为false
  if (isHappy)
   {
     printf("I am happy!\n");
    }
  if (!isSad)
   {
     printf("I am not sad!\n");
    }
return 0;
}
  ```
  ## while循环（前置条件循环）
  格式：
  ```c
while(表达式)   //表达式为真，执行循环，直到表达式不为真，退出循环
     循环语句;
  ```
  先判断，后循环
  ## do while循环（后置条件循环）
  ‍
  ```c
do
{循环语句;}
while(判断条件);
  ```
  ## for循环（前置入口循环）
  格式
  ```c
for(表达式1；表达式2；表达式3)
  ```
  **表达式1:**
  初始化部分，初始化循环变量
  **表达式2**:
  条件判断部分，判断循环何时终止
  **表达式3**:
  调整部分，定义循环变量如何变化
  例子：
  ```c
int a=1;
for(a=2;a<10;a++)
   循环语句；
  ```
  <u>**‍注意⚠️：for括号中是分号！分号！分号！不是逗号！！！**</u>
  ## break语句（停止）
  break语句用于终止switch分支和循环
  ```c
break;
  ```
  ‍
  ## continue语句（跳过）
  continue语句用于跳过本次循环后面的代码，直接去判断部分，进行下一次循环的判断
  ```c
continue;
  ```
  continue与break一般有如下用法：
  ```c
if(5==i)
  break;
  ```
  或
  ```c
if(5==i)
  contiue;
  ```
  ‍
[数据结构（数据类型）](数据结构数据类型/index.md)
  # 数据结构（数据类型）

  16位编译器
  |  |  |  |  |
  | --- | --- | --- | --- |
  |  |  |  |  |
  |  |  |  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  32位编译器
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  64位编译器
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  |  |
  ## ASCII码推算
  只需记住几个具有代表性字符的十进制ASC11码值，即可算出常用字符的ASCII码了。
  1. ‘0’的十进制ASCII码为48
  1. ‘A’的十进制ASCII码为65
  1. 'a'的十进制ASCII码为97
  1. 大小字母ASCI码差32
  数字及字母只需将上一个字符的十进制ASCII码加一
  ## 类型转换
  ### 自动类型转换
  ‍
  ### 强制类型转换
  强制类型转换的一般形式如下：
  ```c
（类型名） （表达式）
  ```
  ```c
int i = 10;
float f;
f = (float)i;// 强制转换int为float类型
  ```
  ‍
  ## 不同位数设备数据类型字节数

  ![](assets/3005a2dd-8276-81cf-90a2-ea20b701279b.png)
[数组](数组/index.md)
  # 数组
  ## 定义数组
  定义格式
  ```c
int 数组名[数组大小];
  ```
  ps：int 可以换成其他数据类型
  ## 初始化数组
  格式
  ```c
int 数组名[数组大小]={数1,数2,数三,...}
  ```
  ps：int 可以换成其他数据类型
  花括号中的数不能大于中括号中定义的数组大小
  ## 数组调用
  数组通过下标调用
  格式
  ```c
数组名[下标]
  ```
  ## 注意
  数组也可以用字符串赋值（字符串本质是字符数组）
  ```c
char arr[]=＂字符串...＂;
  ```
[结构体（自定义数据类型）](结构体自定义数据类型/index.md)
  更好的讲解见[结构体（自定义数据类型）](https://www.notion.so/20a5a2dd827680acad5ef215c327a1fd) （建议看这个）

  # 结构体（自定义数据类型）

  struct：结构体（struct）是一种用户定义的数据类型，它允许你将不同类型的数据组合在一起。

  ## 先定义
  定义结构体结构（定义结构体名）

  ```c
struct 结构体名
{
  int 成员名1；//成员1
  float 成员名2；//成员2
  数据类型 成员名3；//成员3
.....
};
  ```
  ## 在定义
  定义结构体变量（定义结构体变量名）
  20250407212847555
  ```c
struct 结构体名 结构体变量名;
  ```
  ## 输入值
  为结构体变量输入值
  ```c
结构体变量名={值1,值2,值3};
  ```
  也可以直接初始化结构体变量
  ```c
struct 结构体名 结构体变量名={值1,值2,.值3}
  ```
  ## 访问
  访问结构体成员
  使用点操作符 . 来访问结构体的成员
  如：
  ```c
printf("%d%d%d",结构体变量名.成员名);
  ```
  ‍
[转义字符](转义字符/index.md)
  ‍
  | **转义字符** | **含义** |
  | --- | --- |
  | n | 换行符（Newline） |
  | t | 水平制表符（Tab） |
  | \ | 反斜杠 \ |
  | ' | 单引号 ' |
  | " | 双引号 " |
  | 0 | 空字符（字符串结束标志） |
  | r | 回车符（Carriage Return） |
  | b | 退格符（Backspace） |
  | a | 响铃符（Alert/Bell） |
  | f | 换页符（Form Feed） |
  | v | 垂直制表符（Vertical Tab） |
  **常用说明：**
  - `\n` 是最常用的转义字符，用于换行输出
  - `\t` 常用于格式化输出，产生一个Tab的间距
  - `\\` 用于输出反斜杠本身
  - `\'` 和 `\"` 用于在字符/字符串中包含引号
  - `\0` 是字符串的结束标志，C语言字符串以此结尾
  **示例代码：**
  ```c
#include <stdio.h>

int main() {
    printf("Hello\nWorld\n");  // 换行
    printf("Name:\tSSBN\n");   // 制表符
    printf("Path: C:\\Users\\\n");  // 反斜杠
    printf("He said: \"Hello\"\n");  // 双引号
    return 0;
}
  ```
[运算符及计算顺序](运算符及计算顺序/index.md)
  ## 运算符及计算顺序
  本页面详细介绍C语言中运算符的**优先级**、**结合性**（运算方向）以及**表达式的计算顺序**。
  **核心概念：**
  - **优先级**：决定哪个运算符先执行（如乘除优先于加减）
  - **结合性**：当多个相同优先级的运算符出现时，决定从左到右还是从右到左计算
  - **计算顺序**：包括运算符优先级、函数参数求值顺序、短路特性等
  掌握这些规则可以避免编写出逻辑错误或难以理解的代码。
  ## 运算符运算方向
  运算符的结合性（运算方向）决定了当多个相同优先级的运算符出现时，按什么顺序进行计算。
  ### 从左到右（L→R）
  大多数运算符都是从左到右结合的：
  - 算术运算符：`+` `-` `*` `/` `%`
  - 关系运算符：`<` `>` `<=` `>=` `==` `!=`
  - 逻辑运算符：`&&` `||`
  - 位运算符：`&` `|` `^` `<<` `>>`
  - 逗号运算符：`,`
  - 成员访问：`.` `->`
  **示例：**
  ```c
int result = 10 - 5 - 2;  // 从左到右：(10-5)-2 = 3
int x = a && b && c;      // 从左到右：(a&&b)&&c
  ```
  ### 从右到左（R→L）
  少数运算符是从右到左结合的：
  - 赋值运算符：`=` `+=` `-=` `*=` `/=` 等
  - 单目运算符：`!` `~` `++` `--` `+`（正号） `-`（负号） `*`（取值） `&`（取地址）
  - 三元运算符：`? :`
  - `sizeof`、强制类型转换
  **示例：**
  ```c
int a, b, c;
a = b = c = 10;  // 从右到左：a = (b = (c = 10))
int x = 5;
int y = ++x;     // 从右到左：先++x，再赋值给y
  ```
  ## 运算符优先级与结合性
  优先级从高到低排列（1最高，15最低）：
  | **优先级** | **运算符** | **说明** | **结合性** |
  | --- | --- | --- | --- |
  | 1 | () [] -> . | 括号、数组下标、结构体成员访问 | L → R |
  | 2 | ! ~ ++ -- + - * & (type) sizeof | 单目运算符、取值、取地址、类型转换 | R → L |
  | 3 |   • / % | 乘、除、取模 | L → R |
  | 4 |   • - | 加、减 | L → R |
  | 5 | << >> | 按位左移、右移 | L → R |
  | 6 | < <= > >= | 关系运算符 | L → R |
  | 7 | == != | 等于、不等于 | L → R |
  | 8 | & | 按位与 | L → R |
  | 9 | ^ | 按位异或 | L → R |
  | 10 | | | 按位或 | L → R |
  | 11 | && | 逻辑与 | L → R |
  | 12 | || | 逻辑或 | L → R |
  | 13 | ? : | 三元条件运算符 | R → L |
  | 14 | = += -= *= /= %= &= ^= |= <<= >>= | 各种赋值运算符 | R → L |
  | 15 | , | 逗号运算符 | L → R |
  **说明**：
  **同一优先级的运算符，运算次序由结合方向所决定。**
  **简单记就是：括号＞！ > 算术运算符（加减乘除） > 关系运算符（两两比较） > &&（与） > ||（或） > 赋值运算符**
  ‍
  **注意⚠️**
  <u>**c语言中函数参数默认是从右向左计算的**</u>
  如：
  ```c
int a=1
printf("%d %d",a,a++);
  ```
  运行结果是：
  ```c
2 1
  ```
  **先计算参数a++再计算参数a**
  # 计算顺序汇总
  ### 1. 运算符优先级和结合性
  c语言中表达式的运算顺序由优先级和结合性决定：
  - **第一步**：先按运算符优先级运算（优先级高的先算）
  - **第二步**：如果相邻若干个运算符优先级相同，则按结合方向来运算
  **示例：**
  ```c
int result = 3 + 4 * 5;     // 先算4*5=20，再算3+20=23
int x = a = b = 10;         // 从右到左：b=10，然后a=b，最后x=a
int y = 10 - 5 - 2;         // 从左到右：(10-5)-2=3
  ```
  ### 2. 函数参数计算顺序
  **c语言在大多数编译器中函数参数从右向左计算**（但不是绝对，因为C语言标准未定义函数参数的计算方向，这取决于所使用的编译器）
  ### 3. 逻辑运算的短路特性
  - `&&`（逻辑与）：如果左边为假，右边不会被计算
  - `||`（逻辑或）：如果左边为真，右边不会被计算
  **示例：**
  ```c
if (a != 0 && b / a > 2) {  // 如果a==0，不会计算b/a，避免除零错误
    // ...
}
  ```
  ‍
  # 常见错误与注意事项
  ### 1. 链式比较错误
  **C语言不支持数学中的链式比较！**
  **错误写法：**
  ```c
if (a < b < c) {  // 错误！这不是判断a<b且b<c
    // ...
}
  ```
  **错误原因：**
  `a < b < c` 会被解析为 `(a < b) < c`，先计算 `a < b` 得到 0 或 1，然后再与 c 比较，这不是你想要的逻辑！
  **正确写法：**
  ```c
if ((a < b) && (b < c)) {  // 正确：用逻辑与连接两个条件
    // ...
}
  ```
  ### 2. 赋值与相等判断混淆
  **注意区分 = 和 ==**
  ```c
// 错误示例
if (a = 10) {  // 这是赋值，不是判断！a被赋值为10，条件恒为真
    // ...
}

// 正确写法
if (a == 10) {  // 这才是判断a是否等于10
    // ...
}
  ```
  ### 3. 自增/自减的副作用
  **避免在同一表达式中多次修改同一变量**
  ```c
int a = 5;
int b = a++ + a++;  // 不推荐！行为未定义或难以预测

// 建议分步写
int a = 5;
int b = a;
a++;
b += a;
a++;
  ```
  ### 4. 运算符优先级陷阱
  **常见易错点：**
  ```c
// 位运算优先级低于关系运算
if (flags & MASK == 0)  // 错误！先算MASK==0，再做&运算
if ((flags & MASK) == 0)  // 正确：加括号明确优先级

// 逻辑与/或优先级低于关系运算
if (a > 0 && b > 0)  // 正确：>优先级高于&&
  ```
  ### 5. 除法和取模的注意事项
  ```c
int a = 5 / 2;      // 结果是2，不是2.5（整数除法）
float b = 5 / 2;    // 结果还是2.0（先算整数除法，再转float）
float c = 5.0 / 2;  // 结果是2.5（浮点数除法）
float d = (float)5 / 2;  // 结果是2.5（强制类型转换）

int mod = -5 % 3;   // 结果是-2（符号与被除数相同）
  ```
  ‍
[运算符详细](运算符详细/index.md)
  # 运算符详细
  注：本页代码块中均为表达式
  # 生僻的

  ### 按位左移
  <<(按位左移)：左移几位就在左边去掉几个并在右边加几个0
  ```c
表达式：123456789<<2//按位左移两位
运算后为：345678900
  ```
  ### 按位右移
  >>:与按位左移相反
  ### 与（两个数与）
  与：两个都真结果为真
  ```c
表达式：1 && 0
运算后：0
  ```
  ### 按位与（多个数与）
  按位与：前后两个字符串的每一位进行与运算
  ```c
表达式：111000 & 051000
运算后为：011000
  ```
  ### 或（两个数或）
  或：有一个真就为真
  ```c
表达式：0||1
运算后：1
  ```
  ### 按位或 |
  和按位与同理
  ### 按位异或^
  异或：两数一样就是真，不一样就是假
  按位异或：前后两个字符串每位进行异或运算
  ```c
表达式：1234^1230
运算后：1110
  ```
  ### 按位取反~
  取反是逻辑取反
  ```c
表达式：~12110
运算后：00001
  ```
  # 一般的
  ### 赋值运算符
  ```c
表达式：a=1
  ```
  运算方向：右→左
  注意⚠️：这样的表达式无效（等号左侧必须是变量名）
  ```c
错误的表达式：12=a
             或
           96=85
  ```
  ‍
  ### 逗号运算符
  规则：从左到右计算各个表达式，最后一个表达式为整个表达式的结果
  ```c
表达式：
c=((a=2),(a++),(b=3),(a+b+5))
  ```
  ‍
  ### 自增运算符++
  自增：变量值增加1
  **前置自增（++a）：** 先自增，再使用
  **后置自增（a++）：** 先使用，再自增
  ```c
// 前置自增示例
a = 5;
b = ++a;  // a先变成6，然后b=6，结果：a=6, b=6

// 后置自增示例
a = 5;
b = a++;  // b先等于5，然后a变成6，结果：a=6, b=5
  ```
  ‍
  ### 取地址运算符&
  取地址：获取变量在内存中的地址
  ```c
int a = 10;
int *p = &a;  // p存储了变量a的内存地址
printf("%p", &a);  // 打印a的地址
  ```
  ### 自减运算符--
  自减：变量值减少1
  **前置自减（--a）：** 先自减，再使用
  **后置自减（a--）：** 先使用，再自减
  ```c
// 前置自减示例
a = 5;
b = --a;  // a先变成4，然后b=4，结果：a=4, b=4

// 后置自减示例
a = 5;
b = a--;  // b先等于5，然后a变成4，结果：a=4, b=5
  ```
  ### 三元运算符 ? :
  三元运算符：简化的if-else语句
  语法：条件 ? 表达式1 : 表达式2
  如果条件为真，返回表达式1的值，否则返回表达式2的值
  ```c
int a = 10, b = 20;
int max = (a > b) ? a : b;  // max = 20

// 等价于：
if (a > b) {
    max = a;
} else {
    max = b;
}
  ```
  ### sizeof运算符
  sizeof：计算数据类型或变量占用的字节数
  ```c
int a = 10;
printf("%d\n", sizeof(int));      // 输出：4
printf("%d\n", sizeof(a));        // 输出：4
printf("%d\n", sizeof(double));   // 输出：8

int arr[10];
printf("%d\n", sizeof(arr));      // 输出：40 (10个int)
  ```
  ### 强制类型转换运算符
  强制类型转换：将一种数据类型转换为另一种
  语法：(目标类型)表达式
  ```c
int a = 10;
int b = 3;
float result = (float)a / b;  // result = 3.333...

double d = 3.14;
int i = (int)d;  // i = 3 (小数部分被截断)
  ```
  ### 取值运算符*
  取值（解引用）：通过指针获取指针指向的变量的值
  ```c
int a = 10;
int *p = &a;  // p存储a的地址
int value = *p;  // value = 10，通过指针p获取a的值
*p = 20;  // 修改p指向的变量的值，此时a = 20
  ```
  ### 点运算符 .
  点运算符：访问结构体变量的成员
  ```c
struct Student {
    char name[20];
    int age;
};

struct Student s1;
s1.age = 20;  // 通过点运算符访问成员
  ```
  ### 箭头运算符 ->
  箭头运算符：通过结构体指针访问成员
  ```c
struct Student *p = &s1;
p->age = 21;  // 等价于 (*p).age = 21
  ```
[指针](指针/index.md)

  ## 声明
  ```c
数据类型*指针变量名;
  ```
  ps：指针变量在内存中的全部空间存的都是别的变量的内存地址（指针是一个地址容器）
  ## 赋值
  赋值为变量地址
  ```c
指针变量名=&变量名
  ```
  ps：&是取地址符
  不能将变量直接赋给指针变量（要先取地址再赋值）
  ## 初始化
  ```c
数据类型*指针变量名=&变量名
  ```
  或初始化为空指针
  ## 调用
  调用指针要带*号，
  但要调用/修改指针所存的的地址则不带*号
  ```c
printf("%d",p);
  ```
  其中p是指针变量

  ~~**指针的使用**~~~~看这个~~[给指针赋带取地址符（&）的表达式，就是修改指针存储的地址（相当于写入模式）](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2245a2dd8276808c84d2efed69f657b3) 
  [给指针直接赋值，就是修改指针指向元素的值（相当于只读模式）](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2245a2dd827680ce883fc6c3393ee93f) 
  **最新版，最精简版：**
  [总结的总结](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2785a2dd827680c3bd83f9440595cac7)
[二维数组](二维数组/index.md)
  ## 声明
  ```c
类型名 数组名 [行大小][列大小];
  ```
  ## 引用
  ```c
数组名 [行下标][列下标];
  ```
  ## 初始化
  ```c
int a [3][3]={1,2,3,4,5,6,7,8,9};
  ```
  将所有数组所有元素排列到一行初始化
[文件](文件/index.md)
  FILE*是c语言的又一种数据类型
  （文件指针型）（常见的有整形，浮点型…）

  <u>**注意⚠️：由于文件的类型是“文件指针型”所以使用文件句柄时无需带\**</u><u>*</u>
  <u>**注意⚠️：虽然文件文件以指针定义，但文件的指针叫句柄，文件内的位置叫文件指针**</u>
  ## 文件的声明（c语言中所有东西都是先声明后使用）
  c语言用指针指向文件以声明文件：（定义一个文件指针类型的指针）
  ```c
FILE *p;//类型名*指针名
  ```
  其中FILE*是数据类型，p是指向文件的指针名
  ## 文件的操作1
  **将文件的操作函数赋值给相应指针，**即可实现文件的操作
  以下是文件的操作函数
  | **函数名** | **功能说明** |
  | --- | --- |
  | fopen() | 打开文件，返回文件指针（句柄） |
  | fclose() | 关闭文件 |
  | fread() | 从文件中读取数据 |
  | fwrite() | 向文件中写入数据 |
  | fseek() | 移动文件指针到指定位置 |
  | ftell() | 获取当前文件指针位置 |
  | fflush() | 刷新缓冲区，立即写入文件 |
  | fprintf() | 格式化写入文件 |
  | fscanf() | 格式化读取文件 |
  | fgets() | 从文件读取一行字符串 |
  | fputs() | 向文件写入一行字符串 |
  | feof() | 检测文件是否到达末尾 |
  例
  ```c
*p=fopen();
  ```
  ## 文件的操作2
  以下说明了文件的操作函数的参数如何书写
  ### fopen 打开
  ```c
fopen("文件名","模式");
  ```
  打开文件可写为
  ```c
FILE*fp=fopen("文件名","模式");
  ```
  其中常用模式有:
  r（读取）
  w（写入）
  a（追加）
  这些只能操作文本文件
  操作二进制文件需要在后面加b：
  rb（读取）（如果文件不存在，返回NULL,存在，则返回相应文件的标识符）
  wb（写入）（如果文件不存在，就创建,如果文件存在就清空文件中所有内容）
  ab（追加）（如果文件不存在，就创建，如果文存在将文件指针偏移到最末尾）

  ps：fopen返回的标识符就是指针
  ### fwrite 写入

  ```c
fwrite (写入内容,写入大小,写入次数,文件句柄);
  ```
  其中：写入内容可以是指针，也可以是字符串（要带双引号）
  文件位置是待写入文件句柄

  ### fclose 关闭
  ```c
fclose (文件句柄);
  ```
  成功返回0
  ### fflush 清空文件写入缓冲区
  当写入数据至文件时，数据不会被立刻写入，而是会等
  1. 缓冲区满
  1. 文件关闭
  1. 进程结束
  再写入，
  使用fflush可手动写入当前缓冲区的内容至文件
  格式：
  ```c
fflush(相应文件的句柄)
  ```
  ### fseek 文件指针偏移
  ```c
fseek(文件句柄,偏移量,偏移位置);
  ```
  其中，
  1. 偏移量为正往右偏移，为负往左偏
  1. 偏移位置只有三个：SEEK_END(末尾），SEEK_SET(起始），SEEK_CUR(当前位置）
  ### ftell 计算文件指针偏移量
  从文件起始开始计算当前文件指针偏移字节数
  ```c
ftell(文件句柄);
  ```


  注意⚠️：函数参数中包含文件句柄的不需要将函数赋值给文件句柄，不包含则需要赋值给文件句柄（换言之只有fopen需要赋值给句柄）
[typedef 创建类型别名](typedef-创建类型别名/index.md)
  ```c
typedef 原类型名 新类型名；
  ```
  type：类型
  define：定义，简称def 
  typedef：定义类型名
  如：
  ```c
typedef int int1；
  ```
[const定义常量](const定义常量/index.md)
  const定义一个不可修改的变量
  定义：
  ```c
const 数据类型 变量名=常量值；
  ```
  相较于#define，const更便于调试（可在调试时当作变量追踪）
  **不是函数不加括号**
[递归](递归/index.md)
  递归是啥？
  **在某个函数定义中调用该函数（自己调用自己）**
  举个例子：
  这东西：
  ```c
int arr(a)
{
	b=arr(a)+1;
	return 0;
}
  ```
  等于这东西：
  ```c
int arr(a)
{
	b={
			b={
	        b={
	            b=....
	              ....
	              ....+1;
	            return 0;
             }+1;
	       return 0;
         }+1;
			return 0;
		}+1
}
  ```
  这是无限递归
  无限递归没有任何意义（只会导致栈溢出，资源耗尽）
  SO,**递归必须有终止条件**（基准情况）

  正确例子：
  ```c
int arr(a)
{
	if(a<=0)
	{return 0;}
	return arr(a-1);
}
  ```
  这是一个无论输入几都会减到0的函数（输负数直接返回0）

  ## 注意：
  递归不能理解为循环，跟循环没关系
  它更类似于公式展开
[强制类型转换](强制类型转换/index.md)
  C语言中乘号不能省略，因此当看到
  这样
  ```c
c=（int）a+b；
  ```
  这样
  ```c
c=a+((char)b)
  ```
  这样
  ```c
（int）3.14
  ```
  ### 关键特征
  看到一堆括号内有数据类型
[其他头文件](其他头文件/index.md)

[数据类型之复数与虚数](数据类型之复数与虚数/index.md)
  复数需要包含<complex.h>头文件
  该文件定义了三种复数精度：
  double complex（双精度复数）
float complex（单精度复数）
long double complex（长双精度复数）
  ↑这三个都属于数据类型↑
  ### 声明
  ```c
float complex 变量名=值；
  ```
  ### 复数值表示
  2+3.0*i 就是 2+3i
  ### 复数运算（需额外声明）
  ```c
float complex a=b+c；
//其中abc均为复数
  ```
  ### 单独取实部/虚部
  ```c
float
  ```
[c语言格式控制符](c语言格式控制符/index.md)
  用于内嵌在printf和scanf中的用于控制输入输出格式的符号
  有这些
  | 格式控制符 | 说明 |
  | --- | --- |
  | %d | 十进制有符号整数（int） |
  | %u | 十进制无符号整数（unsigned int） |
  | %f | 浮点数（float，默认保留6位小数） |
  | %lf | 双精度浮点数（double） |
  | %c | 单个字符（char） |
  | %s | 字符串 |
  | %ld | 长整型（long） |
  | %lld | 长长整型（long long） |
  | %o | 八进制整数 |
  | %x | 十六进制整数（小写字母） |
  | %X | 十六进制整数（大写字母） |
  | %e | 科学计数法表示的浮点数（小写e） |
  | %E | 科学计数法表示的浮点数（大写E） |
  | %g | 自动选择%f或%e格式（较短者） |
  | %p | 指针地址 |
  | %% | 输出百分号%本身 |
