---
{
  "id": "28c5a2dd-8276-80e3-af4c-c6c6203c26f8",
  "url": "https://www.notion.so/28c5a2dd827680e3af4cc6c6203c26f8",
  "created_time": "2025-10-14T09:09:00.000Z",
  "last_edited_time": "2026-01-20T09:32:00.000Z"
}
---

# ✅ 重制-黑马程序员

[1.启动停止连接](1启动停止连接/index.md)
  # 启动停止
  ### 方法1：CMD方法
  ![](assets/28c5a2dd-8276-80fb-b5ab-c05eccc531ba.png)
  ### 方法2：服务中启动停止
  ![](assets/28c5a2dd-8276-8007-b28e-c4329aaba884.png)
  # 连接
  ### 方法1：用MySQL 8.0 Command Line Client
  在开始菜单中的所有程序中
  ![](assets/28c5a2dd-8276-80ef-a2f6-c683db1586fc.png)
  ### 方法2：用CMD
  ```bash
mysql [-h ip地址] [-p 端口号] -u 用户名 -p 回车后再输入密码
  ```
  ps：
  中括号代表其中内容可省略。
  **IP地址和端口号不填默认为本地数据库地址**
[2.SQL通用语法](2sql通用语法/index.md)
  1. SQL语句以分号结尾
  1. SQL不区分大小写，关键字建议用大写
  1. 单行注释：- -注释内容  或  #注释内容（MySQL特有）
  1. 多行注释：/*注释内容*/
  1. [ ]是可选项  < >是必选项  { }是可无限重复
[3.DDL数据定义语言](3ddl数据定义语言/index.md)
  <u>***DDL,数据定义语言，定义数据库对象（数据库，表，字段）***</u>
  ## 数据库操作
    ### 查询
    查询所有数据库
    ```sql
show databases; --查询有哪些数据库
    ```
    查询当前数据库（查询当前是哪个数据库）
    ```sql
select database();--查询当前是哪个数据库
    ```
    ### 创建
    ```sql
create database [if not exist] 数据库名 [default charset 字符集名] [collate 排列规则];
    ```
    翻译：
    if not exist：如果不存在
    default charset：默认字符集
    collect：排序
    PS：
    字符集建议使用utf8mb4
    ### 删除
    ```sql
drop database [if exists] 数据库名;
    ```
    删除某个数据库如果存在
    ### 使用
    ```sql
use 数据库名;
    ```
    切换到某个数据库
  ## 表操作
    ### 查询
    查询当前数据库所有表
    ```sql
show tables
    ```
    查询表结构（查询表的结构而不是内容）
    ```sql
desc 表名;
    ```
    查询指定表的建表语句（查询当时建表时脚本是怎么写的，不包含脚本层注释，包含数据库层注释）
    ```sql
show create table 表名;
    ```

    ### 创建
    ```sql
create table 表名(
  字段1 字段1类型 [comment 字段1注释]
  ......
)[comment 表注释]
    ```
    PS：每句之间用逗号分隔
    语句结束用分号结束
    comment注释与- -注释的区别是：comment注释会存入数据库（数据库层）
     - -与/**/注释不会存入数据库（脚本层）
    ### 修改
    修改表名
    ```sql
alter table 表名 rename to 新表名;
    ```
    添加字段
    ```sql
alter table 表名 add 字段名 类型 [comment 注释] [约束]；
    ```
    修改数据类型（除字段名外的属性）
    ```sql
alter table 表名 modify 字段名 新数据类型;
    ```
    修改字段名和其他（所有属性）
    ```sql
alter table 表名 change 旧字段名 新字段名 类型 [注释][约束];
    ```
    翻译：
    alter：**修改（修改表）**
    modify：**修改（修改字段属性，除了字段名）**
    change：**修改（修改所有字段属性）**
    PS：alter table是修改表，modify和change是其下的子句，**其中modify没有修改字段名的权限**，只能修改除字段名外的属性，**change则可以修改全部属性包括字段名**
    ### 删除
    删除字段
    ```sql
alter table 表名 drop 字段名；
    ```
    删除表
    ```sql
drop table [if exists] 表名;
    ```
    删除指定表，并重新创建该表(格式化表）
    ```sql
truncate table 表名;
    ```
  ## 数据类型
    ### 字符串类型
      | 类型 | 大小 | 描述 |
      | --- | --- | --- |
      | char | 0-255字节 | 定长字符串 |
      | varchar | 0-65535字节 | 变长字符串 |
      | tinyblob | 0-255字节 | 不超过255个字符的二进制数据 |
      | tinytext | 0-255字节 | 短文本字符串 |
      | blob | 0-65535字节 | 二进制形式的长文本数据 |
      | text | 0-65535字节 | 长文本数据 |
      | mediumblob | 0-16777215字节 | 二进制形式的中等长度文本数据 |
      | mediumtext | 0-16777215字节 | 中等长度文本数据 |
      | longblob | 0-4294967295字节 | 二进制形式的极大文本数据 |
      | longtext | 0-4294967295字节 | 极大文本数据 |

      字符：字符串char，变长字符串va～（定长字符串使用空格补位）（定长性能好）

      二进制：二进制blob，短二进制tiny～，中二进制medium～，长二进制long～

      文本：文本text，短文本tiny～，中文本medium～，长文本long～
    ### 数值类型
      | 类型 | 大小 | 有符号范围 | 无符号范围（unsigned） |
      | --- | --- | --- | --- |
      | tinyint | 1字节 | -128～127 | 0～255 |
      | smallint | 2字节 | -32768～32767 | 0～65535 |
      | mediumint | 3字节 | -8388608～8388607 | 0～16777215 |
      | int/integer | 4字节 | -2147483648～2147483647 | 0～4294967295 |
      | bigint | 8字节 | -2^63～2^63-1 | 0～2^64-1 |
      | float | 4字节 | -3.4E+38～3.4E+38 | 0～3.4E+38 |
      | double | 8字节 | -1.7E+308～1.7E+308 | 0～1.7E+308 |
      | decimal |  | 依赖于M(精度)和D(标度)的值 | 依赖于M(精度)和D(标度)的值 |
      PS：解释一下decimal：123.45指精度为5标度为2的数
    ### 日期时间类型
      | 类型 | 大小 | 范围 | 格式 | 描述 |
      | --- | --- | --- | --- | --- |
      | date | 3字节 | 1000-01-01～9999-12-31 | YYYY-MM-DD | 日期值 |
      | time | 3字节 | -838:59:59～838:59:59 | HH:MM:SS | 时间值或持续时间 |
      | year | 1字节 | 1901～2155 | YYYY | 年份值 |
      | datetime | 8字节 | 1000-01-01 00:00:00～9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 日期和时间值 |
      | timestamp | 4字节 | 1970-01-01 00:00:01～2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 时间戳（与datatime只有范围的区别） |
[4.DML数据操作语言](4dml数据操作语言/index.md)
  <u>***DML数据操作语言，对表中数据增删改***</u>
  # 修改
    修改数据（如果没有条件则会修改字段的所有值）
    ```sql
update 表名 set 字段名1=值1,字段名2=值,...[while 条件;
    ```
  # 添加
    给指定字段添加数据
    ```sql
insert into 表名(字段名1，字段名2...) values (值1,值2...);
    ```
    给全部字段添加数据（不指定字段名则值需要与数据库中字段顺序一一对应）
    ```sql
insert into 表名 values (值1,值2...);
    ```
    批量添加数据
    ```sql
--指定字段
insert into 表名(字段名1,字段名2,..) values (值1,值2...),(值1,值2...),(值1,值2);
    ```
    ```sql
--不指定字段（不指定字段名则值需要与数据库中字段顺序一一对应）
insert into 表名 values (值1,值2),(值1,值2),(值1,值2);
    ```
  # 删除
    删除数据（如果不加条件则会删除整张表的值）
    ```sql
delete from 表名 [while 条件];
    ```
    PS：**delete语句不能删除某个字段的值**（**删除字段的值要使用update，将该字段全设置成null**）
    （**delete语句是用来删除行的，不能用来删除列**）
[5.DQL数据查询语言](5dql数据查询语言/index.md)
  <u>***DQL数据查询语言，查询数据库中表的记录***</u>
  # 基本查询（基本语法）
    查询语句以这个顺序书写：
    ```sql
SELECT 字段列表 
FROM 表名列表 
WHERE 条件列表 
GROUP BY 分组字段列表 
HAVING 分组后条件列表 
ORDER BY 排序字段列表 
LIMIT 分页参数
#这些可以写到一行上，分行是为了便于阅读
#这些不一定全有，没有的就不写
    ```
    PS：***是通配符：select * from table 就是查询表（table）中的所有字段**
    PS：**在字段列表后加 ****`as’别名’`**** 或 ****`‘别名’`****来添加别名（别名只会在本次查询起作用，不会上传到数据库）**
    PS：**在字段列表前加 ****`distinct`**** 表示去除重复**
  # 条件查询
    条件列表有如下
    | 比较运算符 | 功能 |
    | --- | --- |
    | > | 大于 |
    | > = | 大于等于 |
    | < | 小于 |
    | < = | 小于等于 |
    | = | 等于（与C不同，只有一个=） |
    | <>或! = | 不等于 |
    | between…and… | 在某范围内（含最大，最小值） |
    | 字段 in(…) | 在in后的列表中的值，多选一（逗号分隔） |
    | like 占位符 | 模糊匹配（_匹配单个，%匹配任意个字符）
如：
张_：匹配所有张开头的二字人名
李%：匹配所有李开头的人名 |
    | 字段 is null | 为空（前面一定要跟字段，否则语法错误） |
    | 字段 is not null | 非空，同上 |

    | 逻辑运算符 | 功能 |
    | --- | --- |
    | and 或 && | 且 |
    | or 或 || | 或 |
    | not 或 ！ | 非，不是 |
  # 聚合函数
    **聚合函数作用于列**
    ### 语法
    ```sql
select 聚合函数(字段列表) from 表名;
    ```
    ### 常见聚合函数
    | 函数 | 功能 |
    | --- | --- |
    | count | 统计数量（字段列表为*，统计整张表有几行） |
    | max | 最大值 |
    | min | 最小值 |
    | avg | 平均值 |
    | sum | 求和 |
  # 分组查询
    ### 语法
    ```sql
select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后条件]；
    ```
    PS：where与having区别（这两个都是筛选）
    执行时机不同：
    where是分组前过滤，不满足where，不参与分组，having是分组后对结果过滤
    判断条件不同：
    **聚合函数在where后，having前执行**

    例1：根据性别分组，统计男员工和女员工数量
    ```sql
select count(*) from emp group by gender；
#emp：员工表表名
#gender：性别字段
    ```
    例2: 根据性别分组，分别统计男员工和女员工平均年龄
    ```sql
select avg(age) from emp group by gender;
#emp：员工表表名
#gender：性别字段
#age:年龄字段
    ```
    例3:查询年龄小于45的员工，根据工作地址分组，获取员工数量大于等于3的工作地址
    ```sql
select workaddress，count(*) from emp where age<45 group by workaddress having count (*)>=3;
#workdress工作地址字段
#emp表名
#age年龄字段
    ```
    ### 总结
    分组查询语法结构如下
    ```sql
select 字段1,字段2...from...group by 字段3；
    ```
    **字段1 与 字段2 都按照 字段3 中的种类分组，与字段3（一般使用聚合函数查询与分组有关的字段）**
    **查询与分组无关的字段，输出无意义的表格**
    如：按男女分类，统计各性别人数，时加入姓名查询。则姓名查询的输出无意义
  # 排序查询
    语法
    ```sql
select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方;
    ```
    ### 排序方式（就两种）
    | 排序方式 | 作用 |
    | --- | --- |
    | asc | 升序（默认） |
    | desc | 降序 |
    注意⚠️：**SQL支持多字段排序，多字段排序按照写的先后顺序排序**
  # 分页查询
    语法
    ```sql
select 字段列表 from 表名 limit 起始索引,查询记录数;
    ```
    注意⚠️：
    1. 起始索引从0开始，起始索引=（查询页码-1）x 每页记录数
    1. 分页查询各方言不同，mySQL关键字是limit
    1. 如果查询的是第一页数据，可省略起始索引，直接简写为：limit 查询记录数
    PS：
    起始索引就是偏移量
    查询记录数就是每页的记录数
  # DQL执行顺序
    **之前讲的是编写顺序而非执行顺序**
    执行顺序：
    1. from 表名列表 
    1. where 条件列表
    1. group by 分组字段列表
    1. select 字段列表
    1. order by 排序字段列表
    1. limit 分页参数
[6.DCL数据控制语言](6dcl数据控制语言/index.md)
  <u>***DCL数据控制语言,创建数据库用户，控制数据库访问权限***</u>
  # 管理用户
    1. 查询用户
    ```sql
use mysql;
select * from user;
    ```
    **mySQL的用户信息存放在系统数据库 ’mysql’ 中的 ’user’ 表里**

    1. 创建用户
    ```sql
create user '用户名'@'主机名' identified by '密码';
    ```
    **只希望在本地访问，主机名填localhost**
    **希望任意主机访问，主机名填%**

    1. 修改用户密码
    ```sql
alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';
    ```
    mysql_native_password 是密码加密方式

    1. 删除用户
    ```sql
drop user '用户名'@'主机名';
    ```
  # 权限控制
    ### 语法
    1. 查询用户拥有的权限
    ```sql
show grants for '用户名'@'主机名';
    ```
    1. 授予用户权限
    ```sql
grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';
    ```
    可以只给用户授权指定的数据库/表
    如果给用户赋所有数据库和表则填 *. *
    1. 撤销用户权限
    ```sql
revoke 权限列表 no 数据库名.表名 from '用户名';
    ```
    同2
    ### 权限列表
    | 权限 | 说明 |
    | --- | --- |
    | all，all privileges | 所有权限 |
    | select | 查询数据 |
    | insert | 插入数据 |
    | update | 修改数据 |
    | delete | 修改数据 |
    | alter | 修改表 |
    | drop | 删除数据库/表/视图 |
    | create | 创建数据库/表 |
    多个权限之间使用逗号分隔
[7.函数](7函数/index.md)
  **函数的参数可以是字段名**
  # 字符串函数
    mySQL内置了很多字符串函数，常用的有
    | 函数 | 功能 |
    | --- | --- |
    | concat(s1,s2,sn) | 字符串拼接,将S1,S2,..Sn拼接成一个字符串 |
    | lower (str) | 将字符串str全部转为小写 |
    | upper(str) | 将字符串str全部转为大写 |
    | lpad(str,n,pad) | 左填充，用字符串pad对str的左边进行填充,直到总长为n个字符串长度 |
    | rpad(str,n,pad) | 右填充,用字符串pad对str的右边进行填充，直到总长为n个字符串长度 |
    | trim (str) | 去掉字符串头部和尾部的空格 |
    | substring (str,start,len) | 返回从字符串str从start位置起的len个长度的字符串(start和len是一个数字代表了第几个字符，从1开始) |
    **以上函数的语法是：**
    ```sql
select 函数(参数);
    ```
  # 数值函数
    常见的数值函数
    | 函数 | 功能 |
    | --- | --- |
    | ceil(x) | 向上取整（只要有小数，就会向上进位） |
    | floor(x) | 向下取整（只要有小数，就会向下进位 |
    | mod(x,y) | 返回x/y的模（就是x除y，取余数） |
    | rand() | 返回0~1内的随机数 |
    | round (x,y) | 求参数x的四舍五入的值，保留y位小数 |
    **语法同上**
  # 日期函数
    常见的日期函数
    | 函数 | 功能 |
    | --- | --- |
    | curdate() | 返回当前日期 |
    | curtime() | 返回当前时间 |
    | now() | 返回当前日期和时间 |
    | year(date) | 获取指定date的年份[当前年date填now() ] |
    | month(date) | 获取指定date的月份[当前月date填now() ] |
    | day(date) | 获取指定date的日期[当前日date填now() ] |
    | date_add(date,interval exper typr) | 返回一个日期/时间值加上一个时间间隔expr后的时间值
[date是指定时间，expr是增加的时间，type是增加时间的单位：有year,month,day三种] |
    | datediff(date1,date2) | 返回起始时间date1和结束时间date2之间的天数 |
    **语法同上**
  # 流程函数
    常见函数
    | 函数 | 功能 |
    | --- | --- |
    | if(value,t,f) | 如果value为true,则返回t，否则返回f |
    | ifnull(value1,value2) | 如果value1不为空，返回value1，否则返回value2(value1需是default才是空，空字符串不是空） |
    | case [字段] when [val1] then [res1]…else [default] end | 如果val1为true,返回res1,…否则返回default默认值
 |
    | CASE [expr] WHEN [val1] THEN [resl].ELSE [default] END | 如果expr的值等于vall，返回res1，...否则返回default默认值 |
    写的时候不带方括号，方括号表示可选
    第3个举例说明：
    ```sql
select
  name,
  case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end
from emp;
#name:姓名字段
#workaddress：工作地址字段
#emp：表名
    ```
[8.约束](8约束/index.md)
  # 语法
  列级：
  ```sql
字段名 字段类型 [约束]
  ```
  表级：
  ```sql
约束 (对应字段)
  ```
  **约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束**
  # 常见约束
  | 约束 | 描述 | 关键字 |
  | --- | --- | --- |
  | 非空约束 | 限制该字段的数据不能为null | not null |
  | 唯一约束 | 限制该字段的所有数据都是不重复的 | unique |
  | 主键约束 | 主键是一行数据的唯一标识,要求非空且唯一 | primary key |
  | 默认约束 | 保存数据时，如果未指定该字段的值，则采用default后的值作为默认值 | default |
  | 检查约束（8.0.16版本后） | 检查字段的值满足check后的条件 | check |
  | 外键约束 | 用来让两张表的数据之间建立连接,保证数据的一致性和完整性 | foreign key |
  其他约束关键字：
  auto_increment：自增
  # 外键约束
    ## 添加外键
    ### 语法
    写法1 : 建表时添加外键
    ```sql
create table 表名 (
  字段名 数据类型,
  ...
  [constraint][外键名] foreign key (外键字段名) references 主表(字段名)
);
    ```
    写法2 : 建表后添加外键
    ```sql
alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表字段名);
    ```
    **注意⚠️：在添加外键之前要先创建两个表中相应的字段，以上的语句只起到关联两个字段的作用，不会创建字段**
    > PS：关于为什么在建表时 “constraint 外键名称” 是可选的？
标准的写法就是第二种写法，但在建表时可以省略  “constraint 外键名称”  ，这样的外键叫 “匿名外键” ，与c语言的结构体不同，这里的匿名外键实际上会被系统自动起一个名字，因此也是可以删除的（需要先查询外键名字）
    ## 删除外键
    ### 语法
    ```sql
alter table 表名 drop foreign key 外键名;
    ```
    ## 外键约束
    与约束不同，外键约束定义的是当父表删除/更新时，子表如何处理
    | 行为 | 说明 |
    | --- | --- |
    | no action
（默认） | 当在父表中删除更新对应记录时,首先检查该记录是否有对应外键如果有则不允许删除/更新。
（与restrict相同） |
    | restrict | 当在父表中删除/更新对应记录时,首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与no action相同） |
    | cascade | （级联）当在父表中删除/更新对应记录时,首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。 |
    | set null | 当在父表中删除对应记录时,首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取nul) |
    | set default | 父表有变更时，子表将外键列设置成一个默认的值(MySQL的引擎lnnodb不支持) |
    ### 语法
    在创建外键的语句后面加上 “on updat 关键字 on delete 关键字” 来定义在修改和删除时的处理策略
    （下面以写法二为例）
    ```sql
alter table 表名 add constraint 外键名 foreign key (外键字段) references 主表名 (主表字段) on update 行为 on delete 行为;
    ```
    > 级联删除会删除相应的整条记录，而非相应记录的某个字段
  # 表级约束/列级约束
    ## 表级约束
      ### 增
      方法1：建表时添加
      ```sql
CREATE TABLE 表名 (  
  字段1,  
  字段2,
  ....
  约束1 (相应字段1),  
  约束2 (相应字段2)
);
      ```
      方法二：建表后添加
      ```sql
ALTER TABLE 表名
ADD 约束 (相应字段);
      ```
      ### 删
      ```sql
ALTER TABLE 表名
DROP 约束 约束名;
      ```
      PS：约束名是系统自动起的一般叫 `fk_相应字段名`
      PS：删除主键约束（primary key）不用约束名因为主键是唯一的
      ### 改
      没有改的语法，只能先删除再添加
    ## 列级约束
      **列级约束与字段捆绑，想要增删改列级约束要使用字段的增删改方法**
[9.多表查询](9多表查询/index.md)
  # 多表关系
    **一对多（用外键管理）**
    如部门和员工
    **多对多（用中间表管理）（对应多表连接）**
    如学生和课程
    **一对一（用正常表管理，或拆分管理）（对应表拆分）**
    员工和工号
  # 别名
    多表查询经常使用表别名
    语法如下（在表名后空一格紧跟别名即可）
    ```sql
select 字段列表
from 表名1 别名1 ,表名2 别名2....
...
...
...
    ```
  # 多表查询
    说在最前面
    例子：
    ```sql
select 表名1.字段1,表名2.字段2 
from 表名1,表名2 
where 表名1.字段1=表名2.字段2;
--这是隐式内连接
    ```
    ps：**SQL支持同时查询多张表，只需要在表名后加逗号分隔开即可，但查询出来的结果如果不加限制，则是两个表的“笛卡尔积”（第一个表中的相应字段分别与第二个表中的相应字段排列组合，输出所有组合的结果）**
    **PS：所以多表查询要在后面限制查询条件，让两个表有逻辑的字段相等**
    ## 连接查询
    ### **内连接：匹配不上的不返回**
    **隐式**（用限制条件筛选结果）
    ```sql
select 表名1.字段1,表名2.字段2 
from 表名1,表名2 
where 表名1.字段1=表名2.字段2;
    ```
    PS：不在字段列表声明哪个字段属于哪个表也行，只要各个表字段名不重复，像这样↓
    ```sql
select 字段1,字段2 
from 表名1,表名2 
where 表名1.字段1=表名2.字段2;
    ```
    **显式**
    ```sql
select 表名1.字段1,表名2.字段2
from 表1 [inner]join 表2 
on 表名1.字段1=表名2.字段2;

--join后跟要连接的右表
--on后跟连接逻辑（哪两个字段相等）
    ```
    PS：显式与隐式没有区别，只是可读性不同
    ### **外连接**：匹配不到的也返回
    左外连接：
    返回左表的所有记录，即使右表中没有匹配的行；右表匹配不到的字段将填充为 NULL**（按照on/where后指定的字段匹配）**
    ```sql
select 字段列表
from 表1 left[outer]join 表2
on 条件;
    ```
    右外连接：
    返回 右表的所有记录，即使左表中没有匹配的行；左表匹配不到的字段填 NULL**（按照on后指定的字段匹配）**
    ```sql
select 字段列表
from 表1 right[outer]join 表2
on 条件;
    ```
    自连接：
    当前表自身连接查询，必须用表别名
    应用：查找同一个表中有联系的字段
    ```sql
select 字段列表
from 表1 别名1 join 表2 别名2
on 条件...;
    ```
    **PS：join…on连接后结果是笛卡尔积，一般使用group by（分组查询）来筛选结果**
  # 联合查询
    ```sql
select 字段列表 from 表1 ...
union [all]
select 字段列表 from 表2 ...;
    ```

    联合查询是将两个查询语句一次执行，将两个输出结果拼接起来
    **PS：与多表查询不同：多表查询按照相应关系查找两个表结果并组合，联合查询只是分别查询两个表，并将结果一次性输出（不组合）**
    **PS：对于联合查询，两表列数必须一致，字段类型必须一致**
    **PS：union all 会直接合并数据，union 会合并后去重**
  # 子查询（适用多步骤查询用一个语句执行）
    insert / update / delete / select 内再嵌套一个 select 就叫子查询
    > **子查询用括号括起来**
    > **构建子查询方法：将多个步骤分布写出，然后再合并**
    ### 标量子查询（返回单个值）
    **常用操作符**
    | 操作符 | 描述 |
    | --- | --- |
    | **=** | 等于 |
    | **< >** | 不等于 |
    | **<** | 小于 |
    | **>** | 大于 |
    | **>=** | 大于于等于 |
    | **<=** | 小于等于 |
    例子1
    ![](assets/2b35a2dd-8276-80e0-b9f4-d6df9ff9c9e2.jpg)
    例2
    ![](assets/2b35a2dd-8276-8038-be0b-daef46d3d2d3.jpg)
    ### 列子查询（返回一列）
    **常用操作符**
    | 操作符 | 描述 |
    | --- | --- |
    | in | 在指定范围内，多选一 |
    | not in | 不在指定范围内 |
    | any | 有一个满足就行 |
    | some | 与any等价 |
    | all | 所有值必须满足 |
    例1:
    ![](assets/2b35a2dd-8276-800d-9492-dd0d6922b705.jpg)
    例2:
    ![](assets/2b35a2dd-8276-8062-8592-c5aa020620b8.jpg)
    例3:
    ![](assets/2b35a2dd-8276-80d1-ac40-dc757a8477a3.jpg)
    ### 行子查询（返回一行）
    常见操作符
    | 操作符 | 描述 |
    | --- | --- |
    | = | 等于 |
    | <> | 不等于 |
    | in | 在某范围内，多选一 |
    | not in | 不在范围内 |
    > 匹配多个字段有两种方法
      1. 字段1=值1  and  字段2=值2
      1. （字段1，字段2）=（值1，值2）
      在行子查询中需要使用第二种方法
    例：
    ![](assets/2b35a2dd-8276-801e-ba82-ed1e02a78d0e.jpg)
    ### 表子查询（返回多行列）
    | 操作符 | 描述 |
    | --- | --- |
    | in | 在某范围内 |
    与行子查询写法相同，只是将=改成in
    原理：以行子查询为基础，只要有一行全匹配就行
    例1:
    ![](assets/2b35a2dd-8276-8080-ba3b-fba10f1368f3.jpg)
    例2:
    ![](assets/2b35a2dd-8276-8004-b1e0-fab56670396d.jpg)
    PS：表子查询结果后接一个别名，可以作为一个新表使用
[10.事务（不是go）](10事务不是go/index.md)
  事务是一组操作的集合，事务会把所有操作作为一个整体向系统提交，要么同时成功，要么全部执行失败
  # 方法1:修改系统变量为手动提交事务，控制事务提交
    ### 查看/设置事务提交
    ```sql
select @@autocommin;
--查询事务提交方式
--查询出为1则代表自动提交/0为手动提交

set @@autocommit=0;
--设置事务提交方式
--1是自动，0是手动
    ```
    ### 提交事务（手动提交）
    ```sql
commit;
    ```
    ### 回滚事务（取消提交）
    ```sql
rollback;
    ```
    **PS：回滚事务并非是提交后回滚而是取消提交**
  # 方法2：不修改系统变量，临时设置手动提交事务
    顺序
    1. 开启事务
    1. 执行语句/抛出异常
    1. 提交事务/回滚事务
    ### 开启事务（临时手动提交，直到执行commit或rollback）
    ```sql
start transaction;
或
begin;
    ```
    ### 提交事务
    ```sql
commit;
    ```
    ### 回滚事务
    ```sql
rollback;
    ```
    **PS：注意⚠️两种方式都需要手动执行commit或rollback，不能自动执行**


  # 事务四大特性（ACID）
  - 原子性：一个事务是最小操作操作单元
  - 一致性：事务完成时，所有数据保持一致
  - 隔离性：事务A和事务B并发，不会相互影响
  - 持久性：事务一旦提交或回滚就是永久的，而非临时
  # 并发事务问题
  **PS：会不会脏读由隔离级别决定，默认隔离级别不会发生脏读，为了提升性能手动降低隔离级别才有可能脏读**
  - 脏读：事务A读到了事务B未提交的数据
  - 不可重复读：事务A两次读取一个记录，两次结果不同（在两次读之间该记录被事务B修改）
  - 幻读：事务A查询不到某条记录，但在插入该记录时发现该记录已经存在（事务B在事务A查询后抢先插入该记录）
  # 事务隔离级别
  | 隔离级别 | 脏读 | 不可重复读 | 幻读 |
  | --- | --- | --- | --- |
  | Read uncommitted（未提交读） | ✓ | ✓ | ✓ |
  | Read committed（以提交读） | x | ✓ | ✓ |
  | Repeatable Read（可重复读） | x | x | ✓ |
  | Serializable（串行化） | x | x | x |
  MySQL默认：Repeatable Read 级别
  Oracle（甲骨文）默认：Read committed级别
  ```sql
select @@transaction_isolation
--查看事务隔离级别
set [session|global] transaction isolation level {read uncommitted|read committed|repeatable read|serializable}
--设置事务隔离级别
/*

session：会话级别（当前客户端窗口有效）
global：所有（对所有会话有效）

*/
  ```
  **@@代表查看当前系统变量信息**
  # go与事务的区别
  **事务控制的是否提交**
  **go只是告诉脚本谁和谁一起执行，不控制提交，有错误不会回滚**
[11.基础篇结束，以下是进阶篇](11基础篇结束以下是进阶篇/index.md)
  进阶篇视频是挑着看的，记录的只是考25年考试要考的，需要在某时间重构
  —2025.11.29
[12. 存储引擎](12-存储引擎/index.md)
  # 体系结构（分四个层）
  连接层：授权，认证，校验权限
  服务层：sql接口，sql解析，sql优化
  引擎层：（索引在引擎层实现）说明存储策略：存储，获取，更新方式
  存储层：磁盘文件
  # 存储引擎(不同表可以使用不同存储引擎)
  **查询当前存储引擎：**
  ```sql
SHOW ENGINES;
  ```
  **选择存储引擎：**
  ```sql
CREATE TABLE XXXXXX ENGINE=INNODB;
  ```
  ## 常见的存储引擎
  | 引擎 | 事务 | 外键 | 行级锁 |
  | --- | --- | --- | --- |
  | INNODB | √ | √ | √ |
  | MyISAM | x | x | 表锁 |
  ## 应用
  INNODB：重要数据，数据完整性要求高的
  MyISAM：不重要的数据
[13.索引](13索引/index.md)
  作用：索引是加速查询的
  没有索引查询需要全表扫描（慢）
  有索引只需要查询索引即可（快）
  | 优点 | 缺点 |
  | --- | --- |
  | 降低io | 占空间 |
  | 降低cpu | 降低了更新表速度（改数据还得改索引，ps：不用手动改） |
  # 索引结构
    | 结构 | 描述 |
    | --- | --- |
    | B+Tree 索引 | 最常见索引类型，所有引擎基本都支持 |
    | Hash 索引 | 底层使用哈希表实现，只有精确匹配索引列查询才有效，不支持范围查询 |
    | R-tree（空间索引） | 是MyISAM引擎的一个特殊索引，主要用于地理空间数据类型，较少使用 |
    | Full-text（全文索引） | 通过建立倒排索引，快速匹配，较少使用 |
    引擎支持情况
    | 索引 | Innodb | myisam | memory |
    | --- | --- | --- | --- |
    | B+Tree索引 | 支持 | 支持 | 支持 |
    | Hash索引 | 不支持 | 不支持 | 支持 |
    | R-tree索引 | 不支持 | 支持 | 不支持 |
    | Full-text索引 | 5.6版本之后支持 | 支持 | 不支持 |
    ## B+树索引
    ### 没有指定索引默认是B+树索引
    度数：一个节点下的子节点个数
    ![](assets/2c55a2dd-8276-812c-8bc8-fe2a16d537a9.jpg)
    优点：
    相比于二叉树，B+树的层级更少，查询效率更高
    所有数据都存储在叶子节点，非叶子节点只存储索引，叶子节点形成有序链表
    支持范围查询和排序操作
    缺点：
    索引的更新和维护成本较高
    对于频繁插入、删除操作的表，B+树需要频繁调整结构
    不适合存储大量重复值的列作为索引
    ## Hash 索引
    优点：
    查询速度非常快，时间复杂度为O(1)
    只需要一次计算就能定位数据位置
    适合等值查询场景
    缺点：
    不支持范围查询
    不支持排序操作
    存在哈希冲突问题
    > InnoDB不支持哈希索引，但有自适应hash功能
  # 索引分类
    | 分类 | 含义 | 特点 | 关键字 |
    | --- | --- | --- | --- |
    | 主键索引 | 针对表中主键创建的索引 | 默认自动创建，只能有一个 | PRIMARY |
    | 唯一索引 | 避免同一个表中某数据列中的值重复 | 可以有多个 | UNIQUE |
    | 常规索引 | 快速定位特定数据 | 可以有多个 |  |
    | 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个 | FULLTEXT |
    ## InnoDB引擎中索引存储形式
    | 分类 | 含义 | 特点 |
    | --- | --- | --- |
    | 聚集索引（Clustered Index） | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
    | 二级索引（Secondary Index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个 |
    ### 聚集索引
    **聚集索引选取规则：**
    1. 如果存在主键，主键索引就是聚集索引。
    1. 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
    1. 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

    聚集索引数据存储情况：（以有主键的情况为例）
    ![](assets/2c55a2dd-8276-811b-a271-db44e564a1c2.jpg)
    如图：叶子节点5中的数据，就是表中主键为5这一行的数据
    **聚集索引叶子节点下挂的是该行的行数据**
    ## 二级索引
    **二级索引下挂的是该值的主键/第一个唯一字段/rowid**
  # 语法
    **创建索引（建表后创建）**
    ```sql
create [unique/fulltext] index 索引名 on 表名 (字段名，...)；
    ```
    可选项：（不指定则创建常规索引）
    unique：唯一索引
    fulltext：全文索引
    PS：
    一个索引关联一个字段叫单列索引
    一个索引关联多个字段叫联合索引

    **查看索引**
    ```sql
show index from 表名；
    ```
    查看表中所有索引

    **删除索引**
    ```sql
drop index 索引名 on 表名；
    ```
  ### 回表查询
  **一个查询，先查询了其他索引找到主键，再查询主键索引找到其他数据**
  这种查询过程叫回表查询
[14. 视图](14-视图/index.md)
  **视图就是虚拟存在的表，视图中数据不在数据库中实际存在**
  视图与多表查询的区别：
  **视图相当于将多表查询语句保存下来，多表查询需要每次重新写查询语句，视图定义好后再次使用只需要查询视图即可**
  # 语法
  ### **创建**
  ```sql
create [or replace] view 视图名 as select语句...
  ```
  PS：视图的数据来源的表叫`基表`
  或
  ```sql
create view
as
查询语句...
  ```
  ### **查询**
  查看创建视图的语句：
  ```sql
show create view 视图名；
  ```
  查询视图数据：
  ```sql
select 字段 from 视图名；
  ```
  PS：视图可以像表一样查询
  ### **修改**
  方法1
  ```sql
与创建视图相同：
将可选项or replace加上即可
  ```
  方法2
  ```sql
alter view 视图名 as select语句...
  ```
  ### 删除
  ```sql
drop view [if exists] 视图名；
  ```
  可选项：
  if exists：如果存在
[存储过程](存储过程/index.md)
