---
{
  "id": "2325a2dd-8276-8078-968f-c556f411352c",
  "url": "https://www.notion.so/51-2325a2dd82768078968fc556f411352c",
  "created_time": "2025-07-16T14:34:00.000Z",
  "last_edited_time": "2025-09-13T05:01:00.000Z"
}
---

# 5️⃣ 51单片机

[注意事项](注意事项/index.md)
  ### 程序编写
  1. 不能return 0；因为return 0；是返回给操作系统，单片机没有操作系统，因此编译不通过（return其他值也不行，单片机主程序不能退出）
  所以给主程序定义为 void main()
  1. C程序必须命名为main.c（项目名可以命其他的）
  ### 代码没问题但功能实现不了？
  **检查数据类型是否正确：51单片机的寄存器是8位的，因此变量一般定义为unsigned char「无符号整形」（8位）如果定义为int（16位）则会丢失后8位的精度**
[点灯](点灯/index.md)
  # 点灯1
  1. 看原理图看灯对应哪个寄存器
  1. 操作寄存器（1高电平0低电平）
  寄存器标号是个标识符
  ### 实现代码
  ```c
#include<对应MCU型号的头文件>
void main()
{
  P2=0xFE;
  /*P2是寄存器标识符，各型号不同详见
    原理图和相应头文件
}
  ```
  其中寄存器标识符可以接收10，8，16，2进制，格式如下：
  10进制：直接数字
  8进制：0开头，后接8进制数
  16进制：0x开头，后接16进制数
  2进制：0b或0B开头，后接2进制数
  ### 注意事项
  1. 如果发现灯亮灭状态与代码状态是补码（灯与代码亮灭状态相反），说明是“共阳接法”（灯是反着接的）代码反一下就行
        与之相反的叫“共阴接法”
  1. 如果灯的方向顺序与代码逻辑顺序反了，且根据原理图检查代码没有错误，有可能是原理图与实际电路板走线不一致
      （严谨的厂家不会犯这种错误，普中51 
      单片机A2原理图就是错的）
  1. 编译器报错“未定义的标识符”：寄存器标号填错（注意区分大小写）

  # 点灯2（按下亮松开灭）
  ps：操作寄存器单个位的方法：看头文件，使用P2_0等标识符
  ps：寄存器不仅能写还能读
  ### 方法
  用分支语句处理：如果寄存器 P1_0为1（高电平）给 P2_0赋值1，否则为0
  ### 注意⚠️
  1. 由于单片机的程序不会退出（循环运行），所以一定要有“否则（else）”不然灯亮起来就不熄灭了（如果用循环语句来控制，在循环结束要有关灯的语句）
  1. 按键按下和弹起会有抖动（通常是20毫秒），所以程序中要“消抖”（看需求，并非必须），消抖方法就是让程序延时20毫秒

  # 点灯3（松开时切换灯亮灭）
  ### 按键松开检测（阻塞执行）
  **标准按键弹起检测逻辑：****（用循环检测按键是否持续按下，而非是否弹起）**
  ![](assets/23a5a2dd-8276-80b0-8eaf-f95998edb28c.jpg)

  检测逻辑：按下检测   用if   ——   按下状态是否持续  用  while（按下后的寄存器状态）+空循环体  如果为否就会退出循环 —— 按钮松开执行的语句
  <u>**通用逻辑：持续状态检查用循环实现**</u>，
                       **单次状态检测用分支**「<u>**一个程序周期（复位→运行→复位）只做一次判断的用分支」**</u>
  **注意⚠️：**
  1. **松开检测在逻辑上必须先判断是否按下，否则就成了”按钮未按下检测“**
  1. **与正常逻辑不同，松开检测是：按下检测，持续按下一直循环（松开跳出循环），松开执行语句**
  1. **总结2就是不要检测“按钮松开”，而是相反，检测一直按下**

  ### 按键消抖
  误区：按键消抖并非是按键是否按下的持续检测，只是屏蔽了第一个高/低电平后几毫秒的电平变化
  消抖代码一般在被触发的代码后面
  # 按一下亮再按一下灭
  开灯和关灯可以直接赋值
  <u>切换亮灭状态则用取反运算符</u>

  # 点灯4（二进制显示，每按一次+1）

  # 点灯5（按钮1灯左移，按钮2灯右移）
  核心：
  使用位移运算符
  移位到头后的循环处理
[烧录程序](烧录程序/index.md)
  1. 连接设备
  1. 打开软件
  1. 选择型号
  1. 选择.hex文件
  1. 点写入
  1. 按按钮重启单片机
  ### 排除故障
  1. 卡在检测设备：MCU型号选错（要与丝印一致）
  1. 烧录时发现没有.hex文件：编译器没有选择“生成.hex文件”
[几个头文件作用](几个头文件作用/index.md)
  ### <REGX52.H>寄存器地址定义文件
  将寄存器地址转换成标识符供调用
  不同单片机该文件不同
  ### <INTRINS.H>编译器内部函数声明
  **就是快捷指令：如_nop_（空操作指令），堆栈操作，浮点数状态检查**
  不同编译器该文件不同
[灯闪烁](灯闪烁/index.md)
  在点灯的基础上加一个延时函数（延时函数用单片机烧录软件生成）
  ### 原理
  写一个死循环，在该循环内执行：开灯，等待，关灯的操作
  等待由一个函数（延时函数）实现，该函数由烧录软件生成
  ### 实现代码
  ```c
#include <REGX52.H>
#include <INTRINS.H>
void Delay1000ms(void)	//@11.0592MHz
{
	unsigned char data i, j, k;

	_nop_();
	_nop_();
	i = 43;
	j = 6;
	k = 203;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void main()
{
	while(1)
	{
		P2=0x00;
		Delay1000ms();
		P2=0xFF;
		Delay1000ms();
	}
}
  ```
  这里涉及两个头文件，详见：[几个头文件作用](https://www.notion.so/2355a2dd82768048a139ddbac345a8c3) 
  包含<INTRINS.H>的原因是延时函数使用了函数_nop_
  延时函数的频率取决于主板晶振频率
  ### 异常问题
  现象：要求隔1000毫秒闪烁，实际闪烁间隔不是1000毫秒
  解决：8051指令集选最老的STC-Y1，选其他的延时时间就不对了
  ## 拓展
  可以让等待时间任意设置而不重新定义函数
  方法：用烧录软件生成1毫秒的延迟函数，给延迟函数添加形参（毫秒数），再延迟函数内套一个形参次数的循环
[延时函数](延时函数/index.md)

  - 用stc烧录程序可以生成延时函数
  - 延时函数稍加改造就可实现想延时几毫秒就延时几毫秒
  ### 具体方法：
  给延时函数内套一个循环（每执行一次减1），函数参数处定义一个变量（用于传递循环次数）
  实现代码：
  ```c
函数名（int x）
{
for(;x>0;x--)
    {
    生成的函数体；
    }
}

  ```
[数码管](数码管/index.md)
  1.单个数码管（静态驱动）
    单个数码管指的是显示一个数字的，而不是一个数码管内有多个数字
    单个数码管可以直接驱动（无需译码器）（静态驱动）
    给相应段编号的led高/低电平即可（参照数码管规格书，原理图）（当led处理即可）
    ![](assets/23b5a2dd-8276-80ac-b78f-fbaff6df314e.png)
    ![](assets/23b5a2dd-8276-8034-bca5-fead9533c511.png)
    为了减少引脚数量，数码管的VCC/GND是全部连接到一个引脚上的，分别有共阳型与共阴型
    ## 具体实现方法
    以多个数码管为一组的器件为例：（需要译码器）（译码器为74LS138）“38译码器”
    思路：将数码管显示数字与数码管显示位数用单独的函数表示（这样代码更加清晰）

    方法1：缺点：（数组内的元素是二进制/十六进制，不能一目了然对应显示的是哪个字符）
    1. 定义一个函数，参数为数码管显示第几位和该位的显示数字/字符
    1. 用多分支语句实现显示第几位的设置（对译码器输入值的设置）（详见[译码器74LS138](https://www.notion.so/23b5a2dd827680a7acf9ced1b971a4f7#23b5a2dd8276806fbbb9e6075cdd3702) ）
    1. 用数组存储要显示的字符对应的二进制码
    1. 用赋值语句将相应二进制码放入与数码管（非公共端）相连的寄存器中（调用数组）

    方法2：（建议）
    1. 定义一个函数，参数为数码管显示第几位和该位的显示数字/字符
    1. 用多分支语句实现显示第几位的设置（对译码器输入值的设置）（详见[译码器74LS138](https://www.notion.so/23b5a2dd827680a7acf9ced1b971a4f7#23b5a2dd8276806fbbb9e6075cdd3702) ）
    1. 用多分支语句实现该位显示字符的设置
  2.多个数码管
    多个数码管直接驱动需要占用太多 IO 口
    因此，需要译码器
    原理：
    动态驱动是将所有数码管的8个显示笔划"a,b,c,d,e,f,g,dp"的同名端连在一起，另外为每个数码管的公共极COM增加位选通控制电路，位选通由各自独立的I/O线控制，当单片机输出字形码时，单片机对位选通COM端电路的控制，所以我们只要将需要显示的数码管的选通控制打开，该位就显示出字形，没有选通的数码管就不会亮。通过分时轮流控制各个数码管的的COM端，就使各个数码管轮流受控显示，这就是动态驱动
    总结：
    给共阳极/共阴极加控制电路，将相同段号连接到一起，快速将各个数码管逐个点亮
    ## 译码器74LS138
    ![](assets/23b5a2dd-8276-80ea-a1bf-ca5c008ed2e5.png)
    用法：（输入端输入的二进制信号转为十进制的值表示了输出端几号引脚接通到GND）
    A,B,C：输入端
    Y0-Y7 输出端，接LED的公共端COM（共阴/共阳极）
    G1,G2A,G2B：使能端，G1高电平，G2A,G2B低电平时该器件工作
    ## 缓冲器74HC245
    ![](assets/23b5a2dd-8276-809f-87a6-dce7922d05ec.png)
    作用：单片机IO口供电能力有限，通过该器件增强电流
    DIR：改变输入输出方向，高电平从A0~7输入，B0~7输出，低电平从B0~7输入，A0~7输出
    A0~7,B0~7:输入/输出
[按课程进度详细](按课程进度详细/index.md)
  LED教程部分异常详见[灯闪烁](https://www.notion.so/2355a2dd82768045a1aef8aaee7a9dfb) 
  2-1点亮一个LED（正式第一节）
    # 实验1（点亮LED）
    1. 打开keil→project→new uvision project（新建项目文件）→选择MCU型号→project中选择target1→右键source group1→add new….
    1. 代码
    ```c
#include <REGX52.H>
void main ()
{
  p2=0xFE//11111110;
}
    ```
    ### 原理
    查看原理图，看要点亮的LED与那个寄存器相连，修改寄存器内的值以改变LED亮灭状态
    解释：
    <REGX52.H>是定义stc89c52单片机寄存器的头文件
    注意⚠️：
    1. 如果LED是共阳接法，寄存器的值与实际亮灭状态是相反的
    1. 给寄存器赋值要用16进制，不能直接用二进制，否则会被当成10进制处理

    PS：手头的开发板不仅是共阳接法，寄存器标号也标反了😅😅😅
    keil默认不生成hex文件，需要点这个
    ![](assets/26d5a2dd-8276-80fc-91a4-e01c7e929c46.jpg)
    在output中勾选create hex file后点击OK
    # 实验二（让程序持续运行）
    在最外层写一个死循环阻止程序退出
    ```c
#include <REGX52.H>
void main ()
{ 
 while(1)
  {
    p2=0xFE//11111110;
  }
}
    ```
  2-2，2-3LED闪烁，led流水灯（软件延时）
    # 实验1（软件延时使用）
    代码：
    ```c
#include <REGX52.H>
#include <INTRINS.H>
void Delay1000ms()		//@11.0592MHz
{	unsigned char i, j, k;
	_nop_();
	i = 8;
	j = 1;	
	k = 243;	
	do	
	{		
	do		
	{			
	while (--k);		
	} 
	while (--j);	
	} 
	while (--i);
	}
/*Delay1000ms是软件延时计算器生成的延时1000ms的函数*/

void main()
{	
while(1)	
{
		P2=0x00;
		Delay1000ms();
		P2=0xFF;		
		Delay1000ms();	
		}
}
    ```
    ### 原理
    利用stc烧录程序提供的软件延时计算器实现：亮—等待—灭—等待，的循环
    ### 注意⚠️
    这个程序需要包含INTRINS.H头文件，这个定义了keil编译器的内置函数
    # 实验2（改造软件延时函数）
    代码：
    ```c
#include <REGX52.H>
#include <INTRINS.H>
void Delay1ms(unsigned int x_ms)		//@11.0592MHz
{
	for( ;x_ms>0;x_ms--)
	{
		unsigned char i, j;

		_nop_();
		_nop_();
		_nop_();
		i = 11;
		j = 190;
		do
		{
			while (--j);
		} while (--i);
	}
}


void main()
{
	while(1)
	{
		P2=0x00;
		Delay1ms(50);
		P2=0xFF;
		Delay1ms(100);
	}
}
    ```
    ### 原理
    1. 生成一个 1ms的延时函数
    1. 给延时函数内套一个执行n次的循环（建议用for循环）
    1. 给延时函数定义一个参数n
    1. 调用函数时传入参数n
    ps：这个n就是延时多少ms
    注意⚠️：定义函数参数时使用了unsigned int“无符号整形”，单片机寄存器只有8位，所以只能使用8位的无符号整形

    ### **for循环：**
    ```c
for(表达式1；表达式2；表达式3)
    ```
    **表达式1:**
    初始化部分，初始化循环变量
    **表达式2**:
    条件判断部分，判断循环何时终止
    **表达式3**:
    调整部分，定义循环变量如何变化

    ### led流水灯
    逻辑：
    修改寄存器为第一个灯亮的值—调用延时函数—…..第二个灯亮的值—调用延时函数……..一直循环
  3-1独立按键控制led亮灭（按键消抖，按键按下判断，单独修改寄存器的一位）
    # 实验1：按下按键灯状态切换
    代码
    ```c
#include <REGX52.H>
#include <INTRINS.H>
void Delay1ms(int xms)		//@11.0592MHz 改造的延时函数
{
	unsigned char i, j;
	for( ;xms>0;xms--)
		{
			

			_nop_();
			i = 2;
			j = 199;
			do
			{
				while (--j);
			} while (--i);
		}
}
void main()
{
while(1)
{		
			if(P3_1==0)
			{
		
			Delay1ms(20);
			while(P3_1==0);
			Delay1ms(20);
			P2=~P2;
			}
}				
}

    ```
    ### 主函数逻辑
    初始化寄存器，先用if分支判断是否按下，没有按下则会阻塞运行，按下则进入循环（循环条件是按键按下寄存器的值），不松开则会阻塞运行，松开后给寄存器的值取反
    ### 按键消抖
    用软件延时计算器生成20ms的延时函数，放在按下和抬起的逻辑后面
    ### 寄存器一位修改
    用P1_1修改，由<REGX52.H>定义
